
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Directional-Field Processing Library">
      
      
      
        <link rel="canonical" href="https://avaxman.github.io/Directional/tutorial/">
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../file_formats/">
      
      
        
      
      
      <link rel="icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Tutorial - Directional</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../css/style.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#directional-tutorial" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Directional" class="md-header__button md-logo" aria-label="Directional" data-md-component="logo">
      
  <img src="../logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Directional
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tutorial
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/avaxman/Directional.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    Directional
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Directional" class="md-nav__button md-logo" aria-label="Directional" data-md-component="logo">
      
  <img src="../logo.png" alt="logo">

    </a>
    Directional
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/avaxman/Directional.git" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    Directional
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Tutorial
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Tutorial
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Introduction
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-the-tutorial-examples" class="md-nav__link">
    <span class="md-ellipsis">
      
        Installing the tutorial examples
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discrete-tangent-bundles" class="md-nav__link">
    <span class="md-ellipsis">
      
        Discrete tangent bundles
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#representation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Representation
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-io-and-visualization" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 1: I/O and Visualization
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1: I/O and Visualization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#visualization-paradigm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Visualization paradigm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#101-glyph-rendering" class="md-nav__link">
    <span class="md-ellipsis">
      
        101 Glyph Rendering
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-discrete-tangent-bundles" class="md-nav__link">
    <span class="md-ellipsis">
      
        102 Discrete Tangent Bundles
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-streamline-tracing" class="md-nav__link">
    <span class="md-ellipsis">
      
        103 Streamline Tracing
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#104-scalar-quantities-on-meshes" class="md-nav__link">
    <span class="md-ellipsis">
      
        104 Scalar quantities on meshes
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#105-sparse-glyph-view" class="md-nav__link">
    <span class="md-ellipsis">
      
        105 Sparse glyph view
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#106-principal-directions" class="md-nav__link">
    <span class="md-ellipsis">
      
        106 Principal directions
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discretization-and-representation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 2: Discretization and Representation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 2: Discretization and Representation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-principal-matching" class="md-nav__link">
    <span class="md-ellipsis">
      
        201 Principal Matching
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-sampling" class="md-nav__link">
    <span class="md-ellipsis">
      
        202 Sampling
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-combing" class="md-nav__link">
    <span class="md-ellipsis">
      
        203 Combing
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-cartesian-methods" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 3: Cartesian Methods
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3: Cartesian Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cartesian-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cartesian Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#301-power-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        301 Power Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#302-polyvectors" class="md-nav__link">
    <span class="md-ellipsis">
      
        302 PolyVectors
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#303-ginzburg-landau-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        303 Ginzburg-Landau Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#304-integrable-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        304 Integrable Fields
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-polar-methods" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4: Polar Methods
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4: Polar Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polar-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        Polar Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#401-index-prescription" class="md-nav__link">
    <span class="md-ellipsis">
      
        401 Index Prescription
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="401 Index Prescription">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basis-cycles" class="md-nav__link">
    <span class="md-ellipsis">
      
        Basis Cycles
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-seamless-integration-and-meshing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 5: Seamless Integration and Meshing
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 5: Seamless Integration and Meshing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#501-seamless-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        501 Seamless Integration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#502-integration-in-various-orders" class="md-nav__link">
    <span class="md-ellipsis">
      
        502 Integration in various orders
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#503-rounding-either-seams-or-singularities" class="md-nav__link">
    <span class="md-ellipsis">
      
        503 Rounding either seams or singularities
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#504-linear-reductions" class="md-nav__link">
    <span class="md-ellipsis">
      
        504 Linear Reductions
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#505-meshing" class="md-nav__link">
    <span class="md-ellipsis">
      
        505 Meshing
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-cochain-complexes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 6: Cochain Complexes
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 6: Cochain Complexes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#601-face-based-finite-elements" class="md-nav__link">
    <span class="md-ellipsis">
      
        601 Face-Based Finite Elements
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#602-discrete-exterior-calculus" class="md-nav__link">
    <span class="md-ellipsis">
      
        602 Discrete Exterior Calculus
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#603-hodge-decomposition" class="md-nav__link">
    <span class="md-ellipsis">
      
        603 Hodge Decomposition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#604-hodge-decomposition-with-boundaries" class="md-nav__link">
    <span class="md-ellipsis">
      
        604 Hodge decomposition with boundaries
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#605-harmonic-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        605 Harmonic Fields
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" class="md-nav__link">
    <span class="md-ellipsis">
      
        Outlook for continuing development
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    <span class="md-ellipsis">
      
        References
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../file_formats/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    File Formats
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../website/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Website
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../RELEASE_HISTORY/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Release History
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Introduction
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-the-tutorial-examples" class="md-nav__link">
    <span class="md-ellipsis">
      
        Installing the tutorial examples
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discrete-tangent-bundles" class="md-nav__link">
    <span class="md-ellipsis">
      
        Discrete tangent bundles
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#representation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Representation
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-io-and-visualization" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 1: I/O and Visualization
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1: I/O and Visualization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#visualization-paradigm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Visualization paradigm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#101-glyph-rendering" class="md-nav__link">
    <span class="md-ellipsis">
      
        101 Glyph Rendering
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-discrete-tangent-bundles" class="md-nav__link">
    <span class="md-ellipsis">
      
        102 Discrete Tangent Bundles
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-streamline-tracing" class="md-nav__link">
    <span class="md-ellipsis">
      
        103 Streamline Tracing
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#104-scalar-quantities-on-meshes" class="md-nav__link">
    <span class="md-ellipsis">
      
        104 Scalar quantities on meshes
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#105-sparse-glyph-view" class="md-nav__link">
    <span class="md-ellipsis">
      
        105 Sparse glyph view
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#106-principal-directions" class="md-nav__link">
    <span class="md-ellipsis">
      
        106 Principal directions
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discretization-and-representation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 2: Discretization and Representation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 2: Discretization and Representation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-principal-matching" class="md-nav__link">
    <span class="md-ellipsis">
      
        201 Principal Matching
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-sampling" class="md-nav__link">
    <span class="md-ellipsis">
      
        202 Sampling
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-combing" class="md-nav__link">
    <span class="md-ellipsis">
      
        203 Combing
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-cartesian-methods" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 3: Cartesian Methods
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3: Cartesian Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cartesian-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cartesian Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#301-power-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        301 Power Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#302-polyvectors" class="md-nav__link">
    <span class="md-ellipsis">
      
        302 PolyVectors
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#303-ginzburg-landau-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        303 Ginzburg-Landau Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#304-integrable-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        304 Integrable Fields
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-polar-methods" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4: Polar Methods
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4: Polar Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polar-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        Polar Fields
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#401-index-prescription" class="md-nav__link">
    <span class="md-ellipsis">
      
        401 Index Prescription
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="401 Index Prescription">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basis-cycles" class="md-nav__link">
    <span class="md-ellipsis">
      
        Basis Cycles
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-seamless-integration-and-meshing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 5: Seamless Integration and Meshing
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 5: Seamless Integration and Meshing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#501-seamless-integration" class="md-nav__link">
    <span class="md-ellipsis">
      
        501 Seamless Integration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#502-integration-in-various-orders" class="md-nav__link">
    <span class="md-ellipsis">
      
        502 Integration in various orders
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#503-rounding-either-seams-or-singularities" class="md-nav__link">
    <span class="md-ellipsis">
      
        503 Rounding either seams or singularities
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#504-linear-reductions" class="md-nav__link">
    <span class="md-ellipsis">
      
        504 Linear Reductions
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#505-meshing" class="md-nav__link">
    <span class="md-ellipsis">
      
        505 Meshing
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-cochain-complexes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 6: Cochain Complexes
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 6: Cochain Complexes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#601-face-based-finite-elements" class="md-nav__link">
    <span class="md-ellipsis">
      
        601 Face-Based Finite Elements
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#602-discrete-exterior-calculus" class="md-nav__link">
    <span class="md-ellipsis">
      
        602 Discrete Exterior Calculus
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#603-hodge-decomposition" class="md-nav__link">
    <span class="md-ellipsis">
      
        603 Hodge Decomposition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#604-hodge-decomposition-with-boundaries" class="md-nav__link">
    <span class="md-ellipsis">
      
        604 Hodge decomposition with boundaries
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#605-harmonic-fields" class="md-nav__link">
    <span class="md-ellipsis">
      
        605 Harmonic Fields
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" class="md-nav__link">
    <span class="md-ellipsis">
      
        Outlook for continuing development
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    <span class="md-ellipsis">
      
        References
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="directional-tutorial">Directional Tutorial<a class="headerlink" href="#directional-tutorial" title="Permanent link">&para;</a></h1>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Directional is a C++ geometry processing library focused on directional-field processing. The functionality is based on the definitions and taxonomy surveyed theoretically in [<a href="#Vaxman2016">Vaxman et al. 2016</a>] and [<a href="#deGoes2016">de Goes et al. 2016</a>], and in many newer papers in the literature, cited within context in this tutorial and the code. Directional contains tools to edit, analyze, and visualize directional fields of various degrees, orders, and symmetries.</p>
<p>Discretization in Directional is abstracted by general discrete tangent bundles that can represent a rich class of directional fields. As a result, many of the library&rsquo;s algorithms can now work seamlessly on multiple representations without modification (for example, power fields can be computed on either vertex-based or face-based fields using the same function).
The library comprises two basic elements:</p>
<ol>
<li>
<p>Classes representing the basic tangent bundle and field structures. They are built with inheritance so that
   functions can be written polymorphically and consequently algorithms can be applied to several representations that have the minimal set of required properties.</p>
</li>
<li>
<p>Standalone functions, implementing directional-field algorithms, that take these classes as parameters.</p>
</li>
<li>
<p>Algebraic structures, such as cochain complexes. </p>
</li>
</ol>
<p>Our paradigm avoids buffed classes with a complicated nested hierarchy; instead, the member functions in the classes are minimal, and only used to implement the essential properties of a geometric object (for instance, the connection between tangent spaces). Nevertheless, Directional strives to minimize the number of cumbersome parameters in functions and therefore relies considerably on (passive) data classes aggregating information about specific algorithms.</p>
<p>The library is header only, where each header contains a set of functions closely related (for instance, the precomputation and computation of some directional quantity over a mesh). For the most part, one header contains only one function. The atomic data structures are, for the most part, simple matrices in <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>,
The visualization is done through a specialized class <code>DirectionalViewer</code>, which is a wrapper around <a href="https://polyscope.run/">PolyScope</a>, with many extended options that facilitate the rendering of directional fields.</p>
<p>The header files contain documentation of the parameters to each function and their required composition; in this tutorial, we mostly tie the functionality of Directional to the theoretical concepts of directional fields and the methods to process and visualize them.</p>
<h3 id="installing-the-tutorial-examples">Installing the tutorial examples<a class="headerlink" href="#installing-the-tutorial-examples" title="Permanent link">&para;</a></h3>
<p>This tutorial comprises an exhaustive set of examples that demonstrate the capabilities of Directional, where every subchapter entails a single concept. The tutorial code can be installed by going into the <code>tutorial</code> folder from the main Directional folder, and typing the following instructions in a terminal:</p>
<div class="highlight"><pre><span></span><code><span class="n">mkdir</span><span class="w"> </span><span class="n">build</span>
<span class="n">cd</span><span class="w"> </span><span class="n">build</span>
<span class="n">cmake</span><span class="w"> </span><span class="o">-</span><span class="n">DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="n">Release</span><span class="w"> </span><span class="p">..</span><span class="o">/</span>
<span class="n">make</span>
</code></pre></div>
<p>This will build all tutorial chapters in the <code>bin</code> folder. The necessary dependencies will be appended and built automatically. To build in Windows, use the <code>cmake-gui ..</code> options instead of the last two commands, and create the project using Visual Studio, with the proper tutorial subchapter as the &ldquo;startup project&rdquo;.</p>
<p>To access a single example, say <code>202_Sampling</code>, go to the <code>bin</code> subfolder, and the executable will be there. Command-line arguments are never required; the data is read from the <code>data</code> folder directly for each example. Some examples save output data in the <code>output</code> folder.</p>
<p>Most examples require a modest amount of user interaction; the GUI should usually be clear on how to do this.</p>
<h3 id="discrete-tangent-bundles">Discrete tangent bundles<a class="headerlink" href="#discrete-tangent-bundles" title="Permanent link">&para;</a></h3>
<p>In the continuum, directional fields are represented as elements (formally: <em>sections</em>) of tangent spaces, where a tangent space is a linear space attached to each point of a manifold. The set of all such tangent spaces is called a <em>tangent bundle</em>. </p>
<p>In the discrete setting, a tangent bundle is a finite graph <span class="arithmatex"><span class="MathJax_Preview">G_{TB} = (V_{TB},E_{TB})</span><script type="math/tex">G_{TB} = (V_{TB},E_{TB})</script></span> of tangent spaces. Each tangent space is an independent vector space of dimension <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>. This concept is implemented in the class <code>TangentBundle</code>. Discrete tangent bundles supply one or more of the following properties:</p>
<ol>
<li>
<p><strong>Intrinsic parameterization</strong>: vectors in a single tangent space are represented with coordinates <span class="arithmatex"><span class="MathJax_Preview">\left(x_1,\cdots,x_d\right)</span><script type="math/tex">\left(x_1,\cdots,x_d\right)</script></span> in an arbitrary, but fixed basis of dimension <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>. The basis itself does not need to be specified for many algorithms; it can stay abstract.</p>
</li>
<li>
<p><strong>Adjacency</strong>: a tangent bundle is represented as a graph where the tangent spaces are nodes, and the graph edges are adjacency relations that encode the local environment of any tangent space. This, in fact, encodes the combinatorial and topological structure of the underlying discrete manifold, akin to the smooth structure in the continuum.</p>
</li>
<li>
<p><strong>Connection</strong>: a connection defines the notion of parallelity in two adjacent tangent spaces, which encodes a metric structure on the underlying manifold, and allows for computing derivatives and curvature. Specifically, a connection is a directed-edge-based quantity on the tangent-bundle graph, given as a change of coordinates between the bases of the source tangent space to the target tangent space. This can be represented as an orthogonal matrix.</p>
</li>
<li>
<p><strong>metric</strong> The metric on the bundle is supplied in two quantities: <code>connectionMass</code> is the weight of each edge <span class="arithmatex"><span class="MathJax_Preview">E_{TB}</span><script type="math/tex">E_{TB}</script></span>, and <code>tangentSpaceMass</code> packs the weights of an inner product on vectors on the bundle. That is, it has either <span class="arithmatex"><span class="MathJax_Preview">V_{TB}</span><script type="math/tex">V_{TB}</script></span> or <span class="arithmatex"><span class="MathJax_Preview">V_{TB}+E_{TB}</span><script type="math/tex">V_{TB}+E_{TB}</script></span> that are the non-zero components of the vector mass matrix.</p>
</li>
<li>
<p><strong>Cycles</strong>: <span class="arithmatex"><span class="MathJax_Preview">G_{TB}</span><script type="math/tex">G_{TB}</script></span> can be equipped with a notion of <em>cycles</em> <span class="arithmatex"><span class="MathJax_Preview">F_{TB}</span><script type="math/tex">F_{TB}</script></span> that are simply-connected closed chains of spaces. Given a connection, the <em>holonomy</em> of a cycle is the failure of a vector to return to itself following a set of parallel transports around the cycle. Concretely, it is encoded in the logarithm of the product of connection matrices. In <span class="arithmatex"><span class="MathJax_Preview">d=2</span><script type="math/tex">d=2</script></span>, holonomy, which is then a single angle, is equivalent to the curvature of the cycle modulo <span class="arithmatex"><span class="MathJax_Preview">2\pi</span><script type="math/tex">2\pi</script></span>. There are two types of cycles, which define the topology of the underlying manifold: <em>local</em> cycles (akin to &ldquo;faces&rdquo; in <span class="arithmatex"><span class="MathJax_Preview">G_{TB}</span><script type="math/tex">G_{TB}</script></span>), which are small closed loops, and <em>global</em> cycles, which can be homological generators and boundary loops. The <em>singularities</em> of fields are defined on the local cycles.</p>
</li>
</ol>
<p>Oftentimes, the above intrinsic quantities are enough for all algorithms; nevertheless, for reasons of input, output, and visualization, a <code>TangentBundle</code> will contain the following, embedding-based extrinsic quantities:</p>
<ol>
<li>
<p><strong>Sources and normals</strong>: point locations and their normals (the codimensional directions of the manifold), which define the tangent planes of the manifold in the Euclidean space. Note that this doesn&rsquo;t mean it&rsquo;s a watertight mesh; that could also encode a point cloud, for instance.</p>
</li>
<li>
<p><strong>extrinsic to intrinsic and back</strong>: functionality that projects extrinsic vectors into intrinsic space (might lose information), or produces the extrinsic representation of an intrinsic directional object.</p>
</li>
<li>
<p><strong>Cycles sources and normals</strong>. Like sources and normals, but for the cycles themselves. These quantities mark the locations of the singularities in space, for visualization purposes.</p>
</li>
</ol>
<p>Two main types are currently implemented in directional: <code>PCFaceTangentBundle</code> implements face-based tangent spaces for 2D triangle meshes, where the fields are tangent to the natural plane supporting the triangles. <code>IntrinsicVertexTangentBundle</code> implements vertex-based intrinsic tangent spaces, which parameterize the cone environment of the <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-ring directly[^Knoeppel_2013]</p>
<p>For example, this is how <code>PCFaceTangentBundle</code> implements the above quantities:</p>
<ol>
<li>Intrinsic parameterization: a local basis in every face.</li>
<li>Adjacency: dual (inner) edges between any two faces.</li>
<li>Connection: the rotation matrix between the bases of any two adjacent faces.</li>
<li>Cycles: the local cycles are around vertex <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-rings, where singularities are then defined as (dual) vertex values, and global cycles are dual loops of generators and boundaries.</li>
<li>Inner product: the natural face-based mass matrix (just a diagonal matrix of face areas).</li>
<li>Sources are face barycenters, and normals are just face normals.</li>
<li>The projection to the supporting plane of the face and encoding in local coordinates.</li>
<li>Vertices and vertex normals (area-weighted from adjacent faces) are the cycle quantities.</li>
</ol>
<p>Some of the choices above can be varied to different flavors of face-based fields (for instance, the metric culminating in the mass weights). <code>PCFaceTangentBundle</code> wraps around a an <em>orientable</em> input triangle mesh in a <em>single connected-component</em>. There are no other limitations on its genus or boundaries. If your input comprises several connected components altogether, you should use several tangent bundles.</p>
<h3 id="representation">Representation<a class="headerlink" href="#representation" title="Permanent link">&para;</a></h3>
<p>The representation of a directional field is its encoding in each discrete tangent plane. The most important element is the number of vectors in each tangent plane, which we denote as the <em>degree</em> of the field <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>. Currently, Directional supports fields that are represented by explicit (intrinsic) coordinates, which we call a <em>cartesian field</em>, and are represented by the class <code>CartesianField</code>. Directional currently supports the following variants of Cartesian fields <a href="#Vaxman2016">[Vaxman et al. 2016]</a>.</p>
<ol>
<li><strong>Raw</strong> - a vector of <span class="arithmatex"><span class="MathJax_Preview">d\times N</span><script type="math/tex">d\times N</script></span> entries represents an intrinsic <span class="arithmatex"><span class="MathJax_Preview">1^N</span><script type="math/tex">1^N</script></span>-vector (a directional with <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> independent vectors in each tangent space) in dimension-dominant ordering: <span class="arithmatex"><span class="MathJax_Preview">(X_{1,1},\ldots, X_{1,d}),(X_{1,2},\ldots,X_{2,d}),\ldots (X_{N,1},\ldots, X_{N,d})</span><script type="math/tex">(X_{1,1},\ldots, X_{1,d}),(X_{1,2},\ldots,X_{2,d}),\ldots (X_{N,1},\ldots, X_{N,d})</script></span> per space (for instance, for <span class="arithmatex"><span class="MathJax_Preview">d=3</span><script type="math/tex">d=3</script></span> and <span class="arithmatex"><span class="MathJax_Preview">N=4</span><script type="math/tex">N=4</script></span> it would be <span class="arithmatex"><span class="MathJax_Preview">xyzxyzxyzxyz</span><script type="math/tex">xyzxyzxyzxyz</script></span> ordering with 12 components per tangent space). Vectors are assumed to be ordered in counterclockwise order in most Directional functions that process raw fields. the memory complexity is then <span class="arithmatex"><span class="MathJax_Preview">dN|V_{TB}|</span><script type="math/tex">dN|V_{TB}|</script></span> for the entire directional field. A Cartesian Field indicates being a raw field by setting <code>CartesianField::fieldType</code> to <code>directional::RAW_FIELD</code>.</li>
<li><strong>Power Field</strong> - This is a unique type to <span class="arithmatex"><span class="MathJax_Preview">d=2</span><script type="math/tex">d=2</script></span>. It encodes an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-rotational-symmetric (<span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy) object as a single complex number <span class="arithmatex"><span class="MathJax_Preview">y=u^N</span><script type="math/tex">y=u^N</script></span> relative to the local basis in the tangent space, where the <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy is the set of roots <span class="arithmatex"><span class="MathJax_Preview">u \cdot e^{\frac{2\pi i k}{N}}, k \in [0,N-1]</span><script type="math/tex">u \cdot e^{\frac{2\pi i k}{N}}, k \in [0,N-1]</script></span>. The magnitude is also encoded this way, though it may be neglected in some applications. The memory complexity is then <span class="arithmatex"><span class="MathJax_Preview">2|V_{TB}|</span><script type="math/tex">2|V_{TB}|</script></span>.</li>
<li><strong>PolyVector</strong> - Also unique to <span class="arithmatex"><span class="MathJax_Preview">d=2</span><script type="math/tex">d=2</script></span>, this is a generalization of power fields that represents an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-directional object in a tangent space as the coefficients <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> of a monic complex polynomial <span class="arithmatex"><span class="MathJax_Preview">f(z)=z^N+\sum_{i=0}^{N-1}{a_iz^i}</span><script type="math/tex">f(z)=z^N+\sum_{i=0}^{N-1}{a_iz^i}</script></span>, which roots <span class="arithmatex"><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> are the encoded <span class="arithmatex"><span class="MathJax_Preview">1^N</span><script type="math/tex">1^N</script></span>-vector field. In the case where the field is an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy, all coefficients but <span class="arithmatex"><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span> are zero. <strong><em>Note</em></strong>: A PolyVector that represents a perfect <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy would have all <span class="arithmatex"><span class="MathJax_Preview">a_i=0,\ \forall i&gt;0</span><script type="math/tex">a_i=0,\ \forall i>0</script></span>, but <span class="arithmatex"><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span> would have the opposite sign from the power-field representation of the same <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy. This is since the power field represents <span class="arithmatex"><span class="MathJax_Preview">u^N</span><script type="math/tex">u^N</script></span> directly, whereas a PolyVector represents the coefficients of <span class="arithmatex"><span class="MathJax_Preview">z^N-u^N</span><script type="math/tex">z^N-u^N</script></span> in this case. The memory complexity is <span class="arithmatex"><span class="MathJax_Preview">2N|V_{TB}|</span><script type="math/tex">2N|V_{TB}|</script></span>.</li>
</ol>
<p>Directional provides a number of conversion functions to switch between different representations. Each of the functions is of the form <code>rep1_to_rep2</code>, where <code>rep1</code> and <code>rep2</code> are the representation names in the above list. e.g., <code>polyvector_to_raw()</code>. Some possible combinations are given by composing two functions in sequence. However, note that not every conversion is possible; for instance, it is not possible to convert from PolyVectors to power fields, as they do not possess the same power of expression. Converting into the more explicit raw representation is often needed for I/O and visualization, but not only.</p>
<h2 id="chapter-1-io-and-visualization">Chapter 1: I/O and Visualization<a class="headerlink" href="#chapter-1-io-and-visualization" title="Permanent link">&para;</a></h2>
<h3 id="visualization-paradigm">Visualization paradigm<a class="headerlink" href="#visualization-paradigm" title="Permanent link">&para;</a></h3>
<p>Directional uses a specialized class called <code>directional::DirectionalViewer</code> which wraps around <code>PolyScope</code>, augmenting it with functionality that pertains to directional fields. A mesh is then stored with its accompanying geometric quantities: the field, edge, vertex, and face-based scalar data, isolines, and more, that we detail in the tutorial per chapter in context. Like PolyScope, Directional supports independent multiple meshes, each with its own set of quantities. The viewer also returns the corresponding PolyScope quantities (for instance, the <code>PolyScope::SurfaceMesh</code>), so that one can use the entire functionality of PolyScope independently.</p>
<h3 id="101-glyph-rendering">101 Glyph Rendering<a class="headerlink" href="#101-glyph-rendering" title="Permanent link">&para;</a></h3>
<p>The most basic operation on directional fields is reading them from a file and drawing them in the most explicit way. In this example, a mesh and a field are read from a file and visualized as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">directional</span><span class="o">::</span><span class="n">readOFF</span><span class="p">(</span><span class="n">TUTORIAL_DATA_PATH</span><span class="w"> </span><span class="s">&quot;/bumpy.off&quot;</span><span class="p">,</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">ftb</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">directional</span><span class="o">::</span><span class="n">read_raw_field</span><span class="p">(</span><span class="n">TUTORIAL_DATA_PATH</span><span class="w"> </span><span class="s">&quot;/bumpy.rawfield&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ftb</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="p">);</span>
<span class="n">directional</span><span class="o">::</span><span class="n">read_singularities</span><span class="p">(</span><span class="n">TUTORIAL_DATA_PATH</span><span class="w"> </span><span class="s">&quot;/bumpy.sings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="p">);</span>

<span class="n">viewer</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">set_surface_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">set_cartesian_field</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">launch</span><span class="p">();</span>
</code></pre></div>
<p>The field is read in <em>raw</em> format (see <a href="../file_formats/">File Formats</a>), which is detailed in the <a href="#introduction">Introduction</a>. The field is <em>face-based</em>, and the singularities are consequently <em>vertex-based</em>,</p>
<p>The singularities and glyphs (and most other properties) can be toggled directly from the common PolyScope GUI. The field (and its singularities) are named <code>field 0</code> and <code>singularities 0</code>, unless a custom name is provided by the user.</p>
<p><img alt="Example 101" src="../images/101_GlyphRendering.png" /></p>
<p align=center><em>Glyph Rendering on a mesh with singularities.</em></p>

<h3 id="102-discrete-tangent-bundles">102 Discrete Tangent Bundles<a class="headerlink" href="#102-discrete-tangent-bundles" title="Permanent link">&para;</a></h3>
<p>This example shows a Cartesian field computed (with the power-field method described in <a href="#301-power-fields">Example 301</a>) on either a vertex-based tangent bundle or a face-based tangent bundle. This highlights the flexibility of choosing a discretization. The relevant code segments are:</p>
<div class="highlight"><pre><span></span><code><span class="n">directional</span><span class="o">::</span><span class="n">IntrinsicVertexTangentBundle</span><span class="w"> </span><span class="n">vtb</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">PCFaceTangentBundle</span><span class="w"> </span><span class="n">ftb</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">callbackFunc</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ImGui</span><span class="o">::</span><span class="n">PushItemWidth</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// Make ui elements 100 pixels wide,</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">FACE_FIELD</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">Button</span><span class="p">(</span><span class="s">&quot;Toggle Vertex Field&quot;</span><span class="p">))</span>
<span class="w">            </span><span class="n">viewingMode</span><span class="o">=</span><span class="n">VERTEX_FIELD</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">VERTEX_FIELD</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">Button</span><span class="p">(</span><span class="s">&quot;Toggle Face Field&quot;</span><span class="p">))</span>
<span class="w">            </span><span class="n">viewingMode</span><span class="o">=</span><span class="n">FACE_FIELD</span><span class="p">;</span>

<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">toggle_singularities</span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">FACE_FIELD</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">toggle_singularities</span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">VERTEX_FIELD</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">toggle_cartesian_field</span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">FACE_FIELD</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">toggle_cartesian_field</span><span class="p">(</span><span class="n">viewingMode</span><span class="o">==</span><span class="n">VERTEX_FIELD</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">ImGui</span><span class="o">::</span><span class="n">PopItemWidth</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">directional</span><span class="o">::</span><span class="n">readOBJ</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span><span class="w"> </span><span class="s">&quot;/elephant.obj&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mesh</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">set_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbackFunc</span><span class="p">);</span>
<span class="n">ftb</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">vtb</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">viewer</span><span class="p">.</span><span class="n">set_surface_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">set_cartesian_field</span><span class="p">(</span><span class="n">rawFaceField</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Face-Based Field&quot;</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">set_cartesian_field</span><span class="p">(</span><span class="n">rawVertexField</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Vertex-Based Field&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">launch</span><span class="p">();</span>
</code></pre></div>
<p>One can see the stages of computing a field: first reading a mesh (<code>readOBJ()</code>), then initializing the approxiate tangent bundle with the mesh (<code>ftb/vtb.init()</code>), and after computing the fields and converting it to raw format, setting the two fields (with appropriate names and ordinal numbers) to the scene. Note that a visual Cartesian field is a separate entity from a surface mesh; the visual quantities needed for Cartesian field are taken from its inner tangent bundle class (you can infact show the field &ldquo;floating&rdquo; without the underlying mesh. <code>viewer.toggle_X()</code> functions are used to control what&rsquo;s shown.</p>
<p><img alt="Example 102" src="../images/102_DiscreteTangentBundles.png" /> <p align=center><em>Power fields on a face-based tangent bundle (left) and vertex-based (right)</em></p></p>
<h3 id="103-streamline-tracing">103 Streamline Tracing<a class="headerlink" href="#103-streamline-tracing" title="Permanent link">&para;</a></h3>
<p>Vector fields on surfaces are commonly visualized by tracing [streamlines] (<a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines</a>). Directional supports the seeding and tracing of streamlines, for all types of directionals. The seeds for the streamlines are initialized using <code>DirectionalViewer::init_streamlines()</code>, and the lines are traced using <code>DirectionalViewer::streamlines_next()</code>. Each call to <code>DirectionalViewer::advance_streamlines()</code> extends each line by one triangle, allowing interactive rendering of the traced lines. The streamline have the same colors as the initial glyphs, where the colors fade into white as the streamline advance.</p>
<p><img alt="Example 103" src="../images/103_StreamlineTracing.png" /><p align=center><em>Tracing the original field (left) into streamlines (right)</em></p></p>
<h3 id="104-scalar-quantities-on-meshes">104 Scalar quantities on meshes<a class="headerlink" href="#104-scalar-quantities-on-meshes" title="Permanent link">&para;</a></h3>
<p>It is possible to set and visualize scalar quantities on meshes at different discretization locations: either face based quantities that appear as flat colors per face, vertex-based (pointwise) quantities that interpolate linearly on faces, appearing smooth, and edge-based (integrated) quantities, that appear as flat quantities on a diamond mesh associates with each edge (taking a <span class="arithmatex"><span class="MathJax_Preview">\frac{1}{3}</span><script type="math/tex">\frac{1}{3}</script></span> of the area of each adjacent triangle). The is controlled by the <code>DirectionalViewer::set_X_data()</code> functions, which also allow the setting of the viewable range of the function (the rest is clipped). The code generating the image below is:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">set_surface_face_data</span><span class="p">(</span><span class="n">faceData</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x of normal&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">set_surface_vertex_data</span><span class="p">(</span><span class="n">vertexData</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sin(y)&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">set_surface_edge_data</span><span class="p">(</span><span class="n">edgeData</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;principal effort&quot;</span><span class="p">);</span>
</code></pre></div>
<p><img alt="Example 104" src="../images/104_FaceVertexEdgeData.png" /><p align=center><em>Edge-, Vertex- and face-based data on a mesh, with the field that induced the matching (Chapter 2).</em></p></p>
<h3 id="105-sparse-glyph-view">105 Sparse glyph view<a class="headerlink" href="#105-sparse-glyph-view" title="Permanent link">&para;</a></h3>
<p>On big meshes, it might appear cumbersome to view <em>all</em> glyphs on every face. It is possible to only view the glyphs on a subsample of faces, by using the <code>sparsity</code> parameter in <code>DirectionalViewer::set_cartesian_field()</code>. This is an integer parameter that controls the density of the sampling, in terms of face distance. Note the setting of the <code>unitToAvgLengthRatio</code> parameter, which controls the length of a vector of unit magnitude, relative to the average edge length.</p>
<p><img alt="Example 105" src="../images/105_Sparsity.png" /><p align=center><em>Dense (sparsity 0) and Sparse (sparsity 5) views of a field as glyphs</em></p></p>
<h3 id="106-principal-directions">106 Principal directions<a class="headerlink" href="#106-principal-directions" title="Permanent link">&para;</a></h3>
<p>Principal directions, the directions of minimum and maximum normal curvature on a mesh, are important quantities for many applications. They are shown in the example below. The new code part is <code>viewer.set_raw_field()</code>, which allows setting a raw field without the entire data structure of a Cartesian field.</p>
<p><img alt="Example 106" src="../images/106_PrincipalDirections.png" /><p align=center><em>The minimum (left) and maximum (right) principal directions, computed on the vertices. The respective normal curvatures are color-coded.</em></p></p>
<h2 id="chapter-2-discretization-and-representation">Chapter 2: Discretization and Representation<a class="headerlink" href="#chapter-2-discretization-and-representation" title="Permanent link">&para;</a></h2>
<p>In the following sections, we show some effects of working with different representations and converting between them.</p>
<h3 id="201-principal-matching">201 Principal Matching<a class="headerlink" href="#201-principal-matching" title="Permanent link">&para;</a></h3>
<p>One of the fundamental operations in directional-field processing is <em>matching</em>. That is, defining which vectors in tangent space <span class="arithmatex"><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span> correspond to those in adjacent tangent space <span class="arithmatex"><span class="MathJax_Preview">t_j</span><script type="math/tex">t_j</script></span>. In Directional, we only work with order-preserving matchings: if vector <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> in tangent space <span class="arithmatex"><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span> is matched to vector <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> in <span class="arithmatex"><span class="MathJax_Preview">t_j</span><script type="math/tex">t_j</script></span>, then for any <span class="arithmatex"><span class="MathJax_Preview">l \in \mathbb{Z}</span><script type="math/tex">l \in \mathbb{Z}</script></span>, vector <span class="arithmatex"><span class="MathJax_Preview">k+l</span><script type="math/tex">k+l</script></span> is matched to vector <span class="arithmatex"><span class="MathJax_Preview">m+l</span><script type="math/tex">m+l</script></span> (modulo <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>). Suppose that the orientation of the TB graph edge is <span class="arithmatex"><span class="MathJax_Preview">t_i \rightarrow t_j</span><script type="math/tex">t_i \rightarrow t_j</script></span>. Then, the matching is encoded as <span class="arithmatex"><span class="MathJax_Preview">m-k</span><script type="math/tex">m-k</script></span>. Given a directional field, the matching is sometimes not known in advance (for instance, when the Cartesian field is input or computed), and it needs to be devised from the field.</p>
<p>Given a raw field (in assumed CCW order in every tangent space), and a matching, one defines the (sum of) rotation angles <span class="arithmatex"><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> (measured against the parallel transport) as the <em>effort</em> of the matching. The process of <em>principal matching</em> [^diamanti_2014] computes the unique matching of least effort, which is within the range of <span class="arithmatex"><span class="MathJax_Preview">[-N\pi, N\pi)</span><script type="math/tex">[-N\pi, N\pi)</script></span> (and therefore denoted as &ldquo;principal&rdquo;). It corresponds to the &ldquo;smallest angle&rdquo; matching for <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy fields.</p>
<p>Principal matching is done through the function <code>principal_matching()</code>, which accepts a Cartesian field as a parameter and computes the following:</p>
<ol>
<li>The matching on each (directed) TB-graph edge. This is stored in the <code>matching</code> member of the field class.</li>
<li>The indices of the cycles. The singular local cycles are stored in the corresponding <code>singLocalCycles</code> and <code>singIndices</code> of the field class.</li>
</ol>
<p>Singularities are computed as the <i>index</i> of each local cycle from the effort around it. The index of a cycle is the sum of efforts around a cycle. A directional must return to itself after a cycle, and therefore, the index is an integer <span class="arithmatex"><span class="MathJax_Preview">I</span><script type="math/tex">I</script></span> when a vector <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> in the face ends up in vector <span class="arithmatex"><span class="MathJax_Preview">m+I</span><script type="math/tex">m+I</script></span>. Note that this can also include multiple full rotations (i.e., this is <em>not</em> taken modulo <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>), where the index can be unbounded. The <em>fractional</em> part of the index is encoded by the matching; however, matching alone cannot encode <em>integral</em> indices (for instance, a single vector field has trivial (Zero) matching anywhere, but can have singularities). This is the reason singularity indices are computed from summing up effort and not matching integers. Note that for face-based fields, the singular cycles are vertices, whereas in vertex-based fields, the singular cycles are faces. Further note that Directional computes singularities only around the <em>local</em> cycles. That is, <code>principal_matching()</code> does not update singularities around boundary or generator loops.</p>
<p>Note that the callback function in this example shows how to pick and select faces on a mesh.</p>
<p><img alt="Example 201" src="../images/201_PrincipalMatching.png" /><p align=center><em>A field with singularities is shown, with a selected face illustrating principal matching via colored vectors</em></p></p>
<h3 id="202-sampling">202 Sampling<a class="headerlink" href="#202-sampling" title="Permanent link">&para;</a></h3>
<p>This is an educational example that demonstrates the loss of information when generating a Cartesian field from rotation angles, and then trying to retrieve them by principal matching. This causes low valence cycles and undersampling causes aliasing in the perceived field. There are three modes seen in the example:</p>
<ol>
<li>
<p><strong>Polar mode</strong>: The user can prescribe the index of a singularity directly, and compute the field with index prescription (see <a href="#index-prescription">example 401</a>). With this, the rotation angles between adjacent faces can be arbitrarily large, and appear as noise in the low-valence cycles.</p>
</li>
<li>
<p><strong>Principal-matching mode</strong>: The rotations are reconstructed from the field, without prior knowledge of the prescribed singularity from the polar mode. The large rotations between adjacent faces are aliased, giving rise to a &ldquo;singularity party&rdquo;: many perceived singularities or a lower index.</p>
</li>
<li>
<p>In the interpolation mode, the field is interpolated from the constrained faces (red) to the free faces (white), keeping the red band fixed from the polar mode. We see a field that is smooth in the Cartesian sense, with more uniformly-placed singularities.</p>
</li>
</ol>
<p><img alt="Example 202" src="../images/202_Sampling.png" /><p align=center><em>Left to right: the polar mode, the principal-matching mode, and the Cartesian mode.</em></p></p>
<h3 id="203-combing">203 Combing<a class="headerlink" href="#203-combing" title="Permanent link">&para;</a></h3>
<p>Given a matching (in this case, principal matching), it is possible to &ldquo;comb&rdquo; the field. That is, re-index the vectors in each tangent space (keeping the CCW order), so that the vector indexing aligns perfectly with the matching to the neighbors&mdash;then, the new matching on the dual edges becomes trivially zero. This operation is important in order to prepare a directional field for integration. In the presence of singularities, the field can only be combed up to a forest of paths that connect between singularities, also known as <em>seams</em>. Note that such paths do not necessarily cut the mesh into a simply-connected patch, but may only connect subgroups of singularities with indices adding up to an integer; as a trivial example, a 1-vector field is always trivially combed, even in the presence of integral singularities, and the set of seams is empty. The combing is done through the function <code>directional::combing()</code>. The matching in the output <code>combedField</code> is already set to the trivial matching in the combed regions, and the correct matching across the seam.</p>
<p><img alt="Example 203" src="../images/203_Combing.png" /><p align=center><em>Colored indices of an uncombed field (left), and a combed one (right). Seams are in black</em></p></p>
<h2 id="chapter-3-cartesian-methods">Chapter 3: Cartesian Methods<a class="headerlink" href="#chapter-3-cartesian-methods" title="Permanent link">&para;</a></h2>
<h3 id="cartesian-fields">Cartesian Fields<a class="headerlink" href="#cartesian-fields" title="Permanent link">&para;</a></h3>
<p>The Cartesian representation is a meta-category for representation of vectors in explicit coordinates, either <span class="arithmatex"><span class="MathJax_Preview">\left(x,y\right)</span><script type="math/tex">\left(x,y\right)</script></span> in some local 2D basis on a tangent plane, or <span class="arithmatex"><span class="MathJax_Preview">\left(x,y,z\right)</span><script type="math/tex">\left(x,y,z\right)</script></span> in the ambient coordinates of the 3D space. The raw, representative (of an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy), power field, and PolyVector representations are all such examples. Cartesian fields often do not automatically contain information about the matching, or rotation, of a field between one face and the next, and it needs to be computed using principal matching. This chapter focuses on computing fields with this representation.</p>
<h3 id="301-power-fields">301 Power Fields<a class="headerlink" href="#301-power-fields" title="Permanent link">&para;</a></h3>
<p>This representation is offered in [<a href="#Knoeppel2013">Knppel et al. 2013</a>], but they did not give it a specific name (the method in general is called &ldquo;globally optimal&rdquo;). We use the name &ldquo;power fields&rdquo; which is coined in [<a href="#Azencot2017">Azencot et al. 2017</a>]. A power field representation uses a complex basis in each tangent plane of a discrete tangent bundle, and represents an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy using a <em>power vector</em>: a single complex number <span class="arithmatex"><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> per face so that its root set <span class="arithmatex"><span class="MathJax_Preview">Y=u^N</span><script type="math/tex">Y=u^N</script></span> comprises the vectors of the <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy.</p>
<p>By prescribing constraints <span class="arithmatex"><span class="MathJax_Preview">Y_C</span><script type="math/tex">Y_C</script></span> on a set of tangent spaces <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, the algorithm interpolates the field to the rest of the spaces <span class="arithmatex"><span class="MathJax_Preview">Y_I = V_{TB} \setminus Y_C</span><script type="math/tex">Y_I = V_{TB} \setminus Y_C</script></span> by minimizing the face-based quadratic Dirichlet energy:</p>
<div class="arithmatex">
<div class="MathJax_Preview">Y_I=\text{argmin}\sum_{e=(f,g) \in E_{TB}}{\omega_e\left|Y_fr_{fg}^N - Y_g\right|^2},</div>
<script type="math/tex; mode=display">Y_I=\text{argmin}\sum_{e=(f,g) \in E_{TB}}{\omega_e\left|Y_fr_{fg}^N - Y_g\right|^2},</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">r_{fg} \in \mathbb{C}</span><script type="math/tex">r_{fg} \in \mathbb{C}</script></span> is the connection coefficient between tangent spaces <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> and <span class="arithmatex"><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span>, and <span class="arithmatex"><span class="MathJax_Preview">\omega_e</span><script type="math/tex">\omega_e</script></span> are the connection weights. For instance, in the face-based <code>PCFaceTangentBundle</code>,  <span class="arithmatex"><span class="MathJax_Preview">r_{fg} = \frac{\overline{e_g}}{\overline{e_f}}</span><script type="math/tex">r_{fg} = \frac{\overline{e_g}}{\overline{e_f}}</script></span>, where <span class="arithmatex"><span class="MathJax_Preview">e_f</span><script type="math/tex">e_f</script></span> and  <span class="arithmatex"><span class="MathJax_Preview">e_g</span><script type="math/tex">e_g</script></span> are the normalized edge vectors in their local complex bases, and the weights <span class="arithmatex"><span class="MathJax_Preview">\omega_e</span><script type="math/tex">\omega_e</script></span> are the harmonic weights as given by [<a href="#Brandt2018">Brandt et al. 2018</a>]. The field is computed through the function <code>directional::power_field()</code>. It is possible to softly prescribe the constraints <span class="arithmatex"><span class="MathJax_Preview">\left\{Y^*_C\right\}</span><script type="math/tex">\left\{Y^*_C\right\}</script></span> with alignment weights <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span>, solving the following minimization problem:</p>
<div class="arithmatex">
<div class="MathJax_Preview">y_I=\text{argmin} \left[\sum_{e=(f,g)\in E_{TB}}{\omega_e\left|Y_fr_{fg}^N  - Y_g\right|^2}+\sum_{c \in C}{\omega_c \left|Y_c - Y^*_c\right|^2}\right],</div>
<script type="math/tex; mode=display">y_I=\text{argmin} \left[\sum_{e=(f,g)\in E_{TB}}{\omega_e\left|Y_fr_{fg}^N  - Y_g\right|^2}+\sum_{c \in C}{\omega_c \left|Y_c - Y^*_c\right|^2}\right],</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\omega_c, \forall c\in C</span><script type="math/tex">\omega_c, \forall c\in C</script></span> are user-controlled. The control of soft vs. hard constraints is expressed in this part of the code: </p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">recompute_field</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">power_field</span><span class="p">(</span><span class="n">vtb</span><span class="p">,</span><span class="w"> </span><span class="n">constVertices</span><span class="p">,</span><span class="w"> </span><span class="n">constVectors</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="o">::</span><span class="n">Constant</span><span class="p">(</span><span class="n">constVertices</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mf">-1.0</span><span class="p">),</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">powerFieldHard</span><span class="p">,</span><span class="w"> </span><span class="n">normalizeField</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">power_field</span><span class="p">(</span><span class="n">vtb</span><span class="p">,</span><span class="w"> </span><span class="n">constVertices</span><span class="p">,</span><span class="w"> </span><span class="n">constVectors</span><span class="p">,</span><span class="w"> </span><span class="n">alignWeights</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">powerFieldSoft</span><span class="p">,</span><span class="w"> </span><span class="n">normalizeField</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>alignWeights</code> parameter can either express a soft constraint <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span>, or, where it is smaller than zero, it encodes a hard constraint that will be interpolated (it&rsquo;s possible to then mix both hard and soft constraints).</p>
<p>If the set <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> is empty, the field is only well-defined up to a global rotation; therefore, the algorithm arbitrarily sets a single vector in one tangent space and interpolates it to the rest of the mesh.</p>
<p><img alt="Example 301" src="../images/301_PowerFields.png" /><p align=center><em>Hard (left) and soft (right) aligned constraints (yellow on red faces) interpolated to the rest of the mesh. Note the singularities that are discovered through principal matching.</em></p></p>
<h3 id="302-polyvectors">302 PolyVectors<a class="headerlink" href="#302-polyvectors" title="Permanent link">&para;</a></h3>
<p>A Polyvector field [^diamanti_2014] is a generalization of power fields that allows for representing independent vectors in each tangent space, invariant to their order. The representation is as the coefficient set <span class="arithmatex"><span class="MathJax_Preview">X_{0 \cdots N-1}</span><script type="math/tex">X_{0 \cdots N-1}</script></span> of a monic complex polynomial in the local complex basis:</p>
<div class="arithmatex">
<div class="MathJax_Preview">P(z) = X_0 + X_1z + \ldots + X_{N-1} z^{N-1} + z^N,</div>
<script type="math/tex; mode=display">P(z) = X_0 + X_1z + \ldots + X_{N-1} z^{N-1} + z^N,</script>
</div>
<p>where the roots <span class="arithmatex"><span class="MathJax_Preview">P(z)=0</span><script type="math/tex">P(z)=0</script></span> are the vectors of the face-based directional object, represented as complex numbers in the local basis. The Dirichlet energy is as for power fields, except with a term for each <span class="arithmatex"><span class="MathJax_Preview">X_i</span><script type="math/tex">X_i</script></span>, with the appropriate power <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>. Note that an <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy is represented as a polynomial where all <span class="arithmatex"><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span>&rsquo;s are zero except <span class="arithmatex"><span class="MathJax_Preview">X_0</span><script type="math/tex">X_0</script></span>. Principal matching, combing, and effort are well-defined on PolyVectors as well.</p>
<p>With the function <code>polyvector_field()</code> one can solve the linear Polyvector problem in its full capacity; the input is a set of prescribed hard constraints <span class="arithmatex"><span class="MathJax_Preview">v_b</span><script type="math/tex">v_b</script></span> per tangent space set <span class="arithmatex"><span class="MathJax_Preview">B \subset V_{TB}</span><script type="math/tex">B \subset V_{TB}</script></span>, where one can prescribe any number of vectors smaller of equal than <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> (unless there is symmetry) per tangent space (that means we allow set <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> to have repeating tangent spaces). Further consider the soft-alignment vectors <span class="arithmatex"><span class="MathJax_Preview">v_c</span><script type="math/tex">v_c</script></span> for face set <span class="arithmatex"><span class="MathJax_Preview">c \subset C</span><script type="math/tex">c \subset C</script></span>, accompanied by an alignment weight <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span> (again with possibly repeating tangent space). We then solve the following quadratic optimization problem:</p>
<div class="arithmatex">
<div class="MathJax_Preview">X_I = \text{argmin} \left(\lambda_S \sum_{n=0}^{N-1}{\sum_{e=(f,g) \in E_{TB}}{\omega_e\left|X_{n,f}r_{fg}^{N-n} - X_{n,g}\right|^2}}\right)+\left(\lambda_R\sum_{n=1}^{N-1}{\sum_{v \in V_{TB}}{w_v\left|X_{n,f}\right|^2}}\right)+\left(\sum_{C,n}{\omega_c\left|X_{n,f}-U_{c}U_{c}^{\dagger}(X_{n,f}-u_{c})+u_{c}\right|^2}\right).</div>
<script type="math/tex; mode=display">X_I = \text{argmin} \left(\lambda_S \sum_{n=0}^{N-1}{\sum_{e=(f,g) \in E_{TB}}{\omega_e\left|X_{n,f}r_{fg}^{N-n} - X_{n,g}\right|^2}}\right)+\left(\lambda_R\sum_{n=1}^{N-1}{\sum_{v \in V_{TB}}{w_v\left|X_{n,f}\right|^2}}\right)+\left(\sum_{C,n}{\omega_c\left|X_{n,f}-U_{c}U_{c}^{\dagger}(X_{n,f}-u_{c})+u_{c}\right|^2}\right).</script>
</div>
<p>So that the set <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is perfectly interpolated. The matrices <span class="arithmatex"><span class="MathJax_Preview">U_{c}</span><script type="math/tex">U_{c}</script></span> and vectors <span class="arithmatex"><span class="MathJax_Preview">u_{c}</span><script type="math/tex">u_{c}</script></span> are designed to create a linear subspace of polynomials for which the respective vectors <span class="arithmatex"><span class="MathJax_Preview">v_c</span><script type="math/tex">v_c</script></span> are roots; for details see Appendix A in [<a href="#Meekes2021">Meekes and Vaxman 2021</a>]. <span class="arithmatex"><span class="MathJax_Preview">\omega_v</span><script type="math/tex">\omega_v</script></span> is the mass of the tangent space (for instance, the area of a face in face-based fields). The last term then measures the soft alignment, also weighted by <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span> per vector. The same technique is used as a hard reduction for the set <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>. The middle term subdues all non-free powers of <span class="arithmatex"><span class="MathJax_Preview">P(z)</span><script type="math/tex">P(z)</script></span>, thus optimizing <span class="arithmatex"><span class="MathJax_Preview">P(z)</span><script type="math/tex">P(z)</script></span> to be as much a power vector as possible. The different energies are also controlled globally by user parameters <span class="arithmatex"><span class="MathJax_Preview">\lambda_S, \lambda_R</span><script type="math/tex">\lambda_S, \lambda_R</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span>. It is also possible to constrain the field to be a perfect power field by setting <span class="arithmatex"><span class="MathJax_Preview">\lambda_R=-1</span><script type="math/tex">\lambda_R=-1</script></span>; in fact <code>power_field()</code> is implemented by calling <code>polyvector_field()</code>. This tutorial examples allows interacting with the alignment weights.</p>
<p>The algorithm is controled by the data structure <code>PolyVectorData</code>, with the important following fields:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">PolyVectorData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">//User parameters</span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXi</span><span class="w"> </span><span class="n">constSpaces</span><span class="p">;</span><span class="w">    </span><span class="c1">// List of tangent spaces where there are (partial) constraints. The faces can repeat to constrain more vectors</span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">constVectors</span><span class="p">;</span><span class="w">   </span><span class="c1">// Corresponding to constSpaces.</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Degree of field</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">TangentBundle</span><span class="o">*</span><span class="w"> </span><span class="n">tb</span><span class="p">;</span><span class="w">        </span><span class="c1">//The tangent bundle on which the field is defined</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">verbose</span><span class="p">;</span><span class="w">                   </span><span class="c1">//whether to output anything</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">signSymmetry</span><span class="p">;</span><span class="w">              </span><span class="c1">// Whether field enforces a ssign symmetry (only when N is even, otherwise by default set to false)</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">wSmooth</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Weight of smoothness</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">wRoSy</span><span class="p">;</span><span class="w">                   </span><span class="c1">// Weight of rotational-symmetry. &quot;-1&quot; means a perfect RoSy field (power field)</span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">wAlignment</span><span class="p">;</span><span class="w">     </span><span class="c1">// Weight of alignment per each of the constfaces. &quot;-1&quot; means a fixed vector</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</code></pre></div>
<p><code>wSmooth</code> is <span class="arithmatex"><span class="MathJax_Preview">\lambda_S</span><script type="math/tex">\lambda_S</script></span>, <code>wRosy</code> is <span class="arithmatex"><span class="MathJax_Preview">\lambda_R</span><script type="math/tex">\lambda_R</script></span>, and <code>wAlignment</code> is <span class="arithmatex"><span class="MathJax_Preview">\omega_c</span><script type="math/tex">\omega_c</script></span> (and where it is <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> this marks a constraint in <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>). <code>verbose</code> should be flagged when output is expected (<code>false</code> by default), and <code>signSymmetry</code> is flagged when the algorithm should enforce that for every vector <span class="arithmatex"><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> in any single PolyVector in a tangent space, the PolyVector also contains <span class="arithmatex"><span class="MathJax_Preview">-u</span><script type="math/tex">-u</script></span> (only if <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> is even); it is <code>true</code> by default.</p>
<p><img alt="Example 302" src="../images/302_PolyVectors.png" /><p align=center><em>Top: Sharp-edge constraints (left; note sometimes more than one per face), Hard (middle) and soft (right) solution. Bottom: dominant-weighted alignment (left), and rotational symmetry (right).</em></p></p>
<p><strong>Extension: PolyVector Iterations</strong>: The polyvector algorithm allows for alternate smooth-and-project iterations, which are commonplace in many algorithms. The next two subchapters of Chapter 3 are examples.</p>
<h3 id="303-ginzburg-landau-fields">303 Ginzburg-Landau Fields<a class="headerlink" href="#303-ginzburg-landau-fields" title="Permanent link">&para;</a></h3>
<p>We demonstrate how to compute fields that minimize the so-called &ldquo;Ginzburg-Landau functional&rdquo; [<a href="#Viertel2017">Viertel and Osting 2017</a>]:
$$
\int{|\nabla v|^2} + \frac{1}{\epsilon}\int{(|v|<sup>2-1)</sup>2},
$$
for some penalty <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> that is assumed to be taken <span class="arithmatex"><span class="MathJax_Preview">\epsilon\rightarrow 0</span><script type="math/tex">\epsilon\rightarrow 0</script></span>. We employ the common MBO algorithm of repeated iterations of smoothing and renormalization. This introduces the <em>polyvector iteration</em> mechanism:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Computing a regular PolyVector field without iterations</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">polyvector_field</span><span class="p">(</span><span class="n">pvData</span><span class="p">,</span><span class="w"> </span><span class="n">pvFieldOrig</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">polyvector_to_raw</span><span class="p">(</span><span class="n">pvFieldOrig</span><span class="p">,</span><span class="w"> </span><span class="n">rawFieldOrig</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">principal_matching</span><span class="p">(</span><span class="n">rawFieldOrig</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//Iterating for a smoothest perfect-RoSy field</span>
<span class="w">    </span><span class="n">pvData</span><span class="p">.</span><span class="n">iterationMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">directional</span><span class="o">::</span><span class="n">PvIterationFunction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iterationFunctions</span><span class="p">;</span>
<span class="w">    </span><span class="n">iterationFunctions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">directional</span><span class="o">::</span><span class="n">hard_rosy</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">polyvector_field</span><span class="p">(</span><span class="n">pvData</span><span class="p">,</span><span class="w"> </span><span class="n">pvFieldGL</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">polyvector_iterate</span><span class="p">(</span><span class="n">pvData</span><span class="p">,</span><span class="w"> </span><span class="n">pvFieldGL</span><span class="p">,</span><span class="w"> </span><span class="n">iterationFunctions</span><span class="p">,</span><span class="w"> </span><span class="n">numIterations</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">polyvector_to_raw</span><span class="p">(</span><span class="n">pvFieldGL</span><span class="p">,</span><span class="w"> </span><span class="n">rawFieldGL</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">principal_matching</span><span class="p">(</span><span class="n">rawFieldGL</span><span class="p">);</span>
</code></pre></div>
<p>The new parts are the function <code>polyvector_iterate</code> that runs an iterative algorithm comprising:</p>
<ol>
<li>
<p>An implicit step reducing the PolyVector energy.</p>
</li>
<li>
<p>Projection steps controlled by all the <code>pvIteration</code> functions in the order they are input.</p>
</li>
</ol>
<p>The basic version is highly configurable, including switching steps (1) and (2), and is controlled by the <code>PolyVectorData</code> structure. This includes, for instance, the ability to slow the implicit step (equivalent to playing with <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>) according to some scheduling. In the GL example, we simply include a project of a polyvector to a perfect RoSy field, using the <code>hard_rosy()</code> function.</p>
<p><img alt="Example 303" src="../images/303_GinzburgLandauFields.png" /><p align=center><em>Left: The original PolyVector Fields. Right: After MBO iterations. Note the improved singularity in the zoom-in.</em></p></p>
<h3 id="304-integrable-fields">304 Integrable Fields<a class="headerlink" href="#304-integrable-fields" title="Permanent link">&para;</a></h3>
<p>This functionality only works with face-based fields via <code>IntrinsicFaceTangentBundle</code>.</p>
<p>Vector-field guided surface parameterization is based on the idea of designing the <em>candidate</em> gradients
of the parameterization functions (which are tangent vector fields on the surface) instead of the functions themselves. Thus, vector-set fields (<span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-Rosy, frame fields, and polyvector fields) that are to be used for parameterization (and subsequent remeshing) should be as <em>integrable</em> as possible: it should be possible to locally comb them into individual vector fields that are approximately gradients of scalar functions. Fields obtained by &ldquo;as-smooth-as-possible&rdquo; design methods do not have this property in general. </p>
<p>In modern methods, this is usually achieved by a smooth-and-reduce-curl approach, which is again doable by the PolyVector Iterations, and using the following projection functions:</p>
<div class="highlight"><pre><span></span><code><span class="n">iterationFunctions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">directional</span><span class="o">::</span><span class="n">soft_rosy</span><span class="p">);</span><span class="w">  </span><span class="n">iterationFunctions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">directional</span><span class="o">::</span><span class="n">curl_projection</span><span class="p">);</span>
</code></pre></div>
<p><code>soft_rosy()</code> works by only taking the PolyVector part-way towards a perfect RoSy, and <code>curl_projection()</code> does principal matching, and then projects out the curl of the field. Following the iterations, the field is by design curl-free numerically, and the <code>curl_matching()</code> retrieves it.</p>
<p><img alt="Example 304" src="../images/304_IntegrableFields.png" /><p align=center><em>Left: The original PolyVector Fields. Right: An Integrable field (the curl is color-coded with maximum of 0.09 at yellow).</em></p></p>
<h2 id="chapter-4-polar-methods">Chapter 4: Polar Methods<a class="headerlink" href="#chapter-4-polar-methods" title="Permanent link">&para;</a></h2>
<h3 id="polar-fields">Polar Fields<a class="headerlink" href="#polar-fields" title="Permanent link">&para;</a></h3>
<p>Polar fields are represented using angles. These angles may encode the rotation from some given basis on a tangent space (and so it is a &ldquo;logarithmic&rdquo; representation, when compared to Cartesian methods), or an angle difference between two neighboring tangent spaces (in the sense of deviation from parallel transport). The former usually requires integer variables for directional-field design. The latter does not, but state-of-the-art methods require the prescription of indices around independent dual cycles in the mesh. Currently, Directional supports the latter.</p>
<h3 id="401-index-prescription">401 Index Prescription<a class="headerlink" href="#401-index-prescription" title="Permanent link">&para;</a></h3>
<p>The notion of encoding rotation angles on dual edges, as a means to encode deviation from parallel transport between adjacent tangent planes, appeared in several formats in the literature [<a href="#Ray2008">Ray et al. 2008</a>]. The formulation and notation we use in Directional is that of Trivial Connections [<a href="#Crane2010">Crane et al. 2010</a>]. Trivial connection solves for a single rotation angle <span class="arithmatex"><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> per (dual) edge <span class="arithmatex"><span class="MathJax_Preview">e_{ij}</span><script type="math/tex">e_{ij}</script></span> between two faces <span class="arithmatex"><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> and <span class="arithmatex"><span class="MathJax_Preview">f_j</span><script type="math/tex">f_j</script></span>, encoding the deviation from parallel transport between them. The algorithm first computes a spanning set of <em>basis cycles</em>, around all of which the sum of <span class="arithmatex"><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> has to be prescribed. The summation is defined as a matrix <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>. Every such cycle (row in the matrix) has an original curvature <span class="arithmatex"><span class="MathJax_Preview">K_0</span><script type="math/tex">K_0</script></span>, and the prescribed index defines an alternative curvature that is induced by the vector field (and hence it&rsquo;s a trivial connection). The algorithm solves for the smoothest field, in the 2-norm least squares sense, as follows:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\delta = \text{argmin}\ |\delta_{ij}|^2\ s.t.\ H\delta = -K_0 + K.
</div>
<script type="math/tex; mode=display">
\delta = \text{argmin}\ |\delta_{ij}|^2\ s.t.\ H\delta = -K_0 + K.
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> is the matrix that defines the basis-cycles sum, <span class="arithmatex"><span class="MathJax_Preview">K_0</span><script type="math/tex">K_0</script></span> is a vector of the original curvatures of every basis cycle, and <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> is the prescribed curvatures, which result from prescribed singularity indices: for regular cycles, we prescribe <span class="arithmatex"><span class="MathJax_Preview">K=0</span><script type="math/tex">K=0</script></span>, and for a singular cycle with prescribed singularity index <span class="arithmatex"><span class="MathJax_Preview">\frac{i}{N}</span><script type="math/tex">\frac{i}{N}</script></span>, we set <span class="arithmatex"><span class="MathJax_Preview">K=\frac{2\pi i}{N}</span><script type="math/tex">K=\frac{2\pi i}{N}</script></span>. the sum of <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> has to conform to the Poincar&eacute; index theorem. However, generator (handle) cycles can admit unbounded indices. See [^crane_2010] for exact details. If the input obeys the sum, the result obeys the prescribed indices around the cycles everywhere. The representation is <em>differential</em>, where the single global degree of freedom is resolved by  setting a single direction in a single arbitrary face. Note that the correct definition for &ldquo;cycle curvature&rdquo; corresponds to the so-called &ldquo;cycle holonomy&rdquo;, only up to integer multiples of <span class="arithmatex"><span class="MathJax_Preview">2\pi</span><script type="math/tex">2\pi</script></span>.</p>
<!---However, in the discrete setting, the curvature should theoretically be computed as the exact discrete angle defect, in which for inner vertices we use $2\pi-\sum{\alpha}$, and for boundary vertices we use $\pi - \sum{\alpha}$ ($\alpha$ are the angles at the corners of a vertex). For a cycle aggregating many vertices, such as a boundary-loop cycle, we add up all the defects. That is required for exact discrete Poincar index consistency. Note that the boundary indices define how many rotations of the vector field the boundary loop "sees". As an example, a constant field on a simple disc in the plane has indices $0$ for all inner vertices, but the boundary index is in fact $1$---This obeys the total index sum $\chi = 2-2g-b = 2-0-1=1$ ($g$ stands for genus and $b$ for number of boundary loops)-->

<h4 id="basis-cycles">Basis Cycles<a class="headerlink" href="#basis-cycles" title="Permanent link">&para;</a></h4>
<p>The basis cycles form the cycles around which curvatures (and singularities) have to be prescribed on the mesh. The sum on basis cycles is described in a sparse matrix <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> of size <span class="arithmatex"><span class="MathJax_Preview">|cycles|\times |E_I|</span><script type="math/tex">|cycles|\times |E_I|</script></span>, where <span class="arithmatex"><span class="MathJax_Preview">E_I</span><script type="math/tex">E_I</script></span> is the number of non-boundary (inner) edges in the tangent bundle <span class="arithmatex"><span class="MathJax_Preview">G_{TB}</span><script type="math/tex">G_{TB}</script></span>. Each row in the matrix describes the sum over one cycle, and contains <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> values depending on the (arbitrary) orientation of the dual edge participating in the cycle to the respective face. The types of indices are defined in The <a href="#discrete-tangent-bundles">introduction</a>. The singularity indices that are prescribed contain the singularity index corresponding to each basis cycle. A value of <span class="arithmatex"><span class="MathJax_Preview">k \in \mathbb{Z}</span><script type="math/tex">k \in \mathbb{Z}</script></span> represents an <span class="arithmatex"><span class="MathJax_Preview">\frac{2\pi k}{N}</span><script type="math/tex">\frac{2\pi k}{N}</script></span> rotation around the respective cycle. If the prescribed indices do not conform to the Poincar&eacute; index theorem, a result will still be computed by least squares, but it will be unpredictable. The algorithm is performed through the function <code>directional::index_prescription()</code>, which can also accept a solver for precomputation, for the purpose of prefactoring <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> only once.</p>
<p><img alt="Example 401" src="../images/401_IndexPrescription.png" /><p align=center><em>Indices are prescribed on several vertex singularities, and on a generator loop, to match the index theorem.</em></p></p>
<h2 id="chapter-5-seamless-integration-and-meshing">Chapter 5: Seamless Integration and Meshing<a class="headerlink" href="#chapter-5-seamless-integration-and-meshing" title="Permanent link">&para;</a></h2>
<p>The full details of the method implemented in this chapter can be found in a technical report <a href="#Vaxman2021">[Vaxman 2021]</a>. Many of the therotical ideas for general <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-functions are explored in <a href="#Meekes2021">[Meekes and Vaxman 2021]</a>. Moreover, this chapter currently only works with <code>IntrinsicFaceTangentBundle</code>.</p>
<p><span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-Directional fields are commonly used as candidate gradients to seamless <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-Functions, which are in turn used to generate meshes that are aligned to the original fields <a href="#Bommes2009">Bommes et al. 2009</a>,<a href="Kalberer2007">Klberer et al. 2007</a>,<a href="#Myles2014">Myles et al. 2014</a>. Recall that <a href="#203-combing">combing</a> trivializes the matching everywhere except a sparse set of seams. We augment these seams so that the mesh is cut into a topological disc. Then, we treat a combed <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-directional <span class="arithmatex"><span class="MathJax_Preview">\left\{u_0,\cdots,u_{N-1} \right\}</span><script type="math/tex">\left\{u_0,\cdots,u_{N-1} \right\}</script></span> as a set of <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> candidate gradients for <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> vertex-based scalar functions <span class="arithmatex"><span class="MathJax_Preview">\left\{F_0,\cdots,F_{N-1}\right\}</span><script type="math/tex">\left\{F_0,\cdots,F_{N-1}\right\}</script></span> on the cut mesh. We proceed by solving the Poisson problem:</p>
<div class="arithmatex">
<div class="MathJax_Preview">F = argmin{\sum_{i=0}^{N-1}{\left|\nabla F_i - u_i\right|^2}}</div>
<script type="math/tex; mode=display">F = argmin{\sum_{i=0}^{N-1}{\left|\nabla F_i - u_i\right|^2}}</script>
</div>
<p>Consider a seam edge <span class="arithmatex"><span class="MathJax_Preview">e_{ij}</span><script type="math/tex">e_{ij}</script></span> between original vertices <span class="arithmatex"><span class="MathJax_Preview">v_i</span><script type="math/tex">v_i</script></span> and <span class="arithmatex"><span class="MathJax_Preview">v_j</span><script type="math/tex">v_j</script></span>, and between adjacent faces <span class="arithmatex"><span class="MathJax_Preview">f_k</span><script type="math/tex">f_k</script></span> and <span class="arithmatex"><span class="MathJax_Preview">f_l</span><script type="math/tex">f_l</script></span>. The two vertices are then cut into four corners <span class="arithmatex"><span class="MathJax_Preview">v_{i,k},v_{j,k},v_{i,l},v_{j,l}</span><script type="math/tex">v_{i,k},v_{j,k},v_{i,l},v_{j,l}</script></span>. Note that some corners might be identical, if the seam edge is at a singularity. Across the seam edge, we enforce the (linear) seamless conditions:</p>
<div class="arithmatex">
<div class="MathJax_Preview">F_{i,k}= \pi_e \cdot F_{i,l}  + T_e,</div>
<script type="math/tex; mode=display">F_{i,k}= \pi_e \cdot F_{i,l}  + T_e,</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\pi_e:N \times N</span><script type="math/tex">\pi_e:N \times N</script></span> is a permutation matrix attached to the (dual) edge <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>, matching values in the integrated function <span class="arithmatex"><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span> as it did for the directional field <span class="arithmatex"><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>. and <span class="arithmatex"><span class="MathJax_Preview">T_e:N \times 1</span><script type="math/tex">T_e:N \times 1</script></span> is a <em>translational jump</em> (also: period jump), that encodes the discontinuity in <span class="arithmatex"><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span> across the seam. For quick intuition, this encodes the integration of the function over a loop around the mesh beginning and ending with the seam edge: in a <span class="arithmatex"><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span>-function, leading to a quad mesh, it is the number of quads in such a loop. If <span class="arithmatex"><span class="MathJax_Preview">T_e \in \mathbb{Z}^N</span><script type="math/tex">T_e \in \mathbb{Z}^N</script></span>, then the <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-function is <em>fully</em> seamless: the integer isolines of a function connect perfectly along a seam. Otherwise, it is only <em>permutationally</em> seamless: the gradients match, which means they are only co-oriented.</p>
<p>Seamless <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-functions are denoted as such for that obeying the seamless constraints; it can be easily shown <a href="#Kaelberer2007">[Klberer et al. 2007]</a> that the translational jumps <span class="arithmatex"><span class="MathJax_Preview">T_e</span><script type="math/tex">T_e</script></span> is in fact uniform across seam curves between singularities. Thus, the number of such translational jump variables is the number of seam curves in the mesh (<span class="arithmatex"><span class="MathJax_Preview">\times N</span><script type="math/tex">\times N</script></span>).</p>
<h3 id="501-seamless-integration">501 Seamless Integration<a class="headerlink" href="#501-seamless-integration" title="Permanent link">&para;</a></h3>
<p>In this example, we demonstrate the computation of such a integration, both permutationally, and fully seamless. The computed function is a <span class="arithmatex"><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span>-function with sign-symmetry, computing seamless <span class="arithmatex"><span class="MathJax_Preview">(U,V,-U,-V)</span><script type="math/tex">(U,V,-U,-V)</script></span> functions that we demonstrate as a quad texture. The core functionality is in these lines:</p>
<div class="highlight"><pre><span></span><code><span class="n">directional</span><span class="o">::</span><span class="n">IntegrationData</span><span class="w"> </span><span class="nf">intData</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">directional</span><span class="o">::</span><span class="n">setup_integration</span><span class="p">(</span><span class="n">rawField</span><span class="p">,</span><span class="w"> </span><span class="n">intData</span><span class="p">,</span><span class="w"> </span><span class="n">meshCut</span><span class="p">,</span><span class="w"> </span><span class="n">combedField</span><span class="p">);</span>
<span class="w">    </span><span class="n">intData</span><span class="p">.</span><span class="n">integralSeamless</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">integrate</span><span class="p">(</span><span class="n">combedField</span><span class="p">,</span><span class="w"> </span><span class="n">intData</span><span class="p">,</span><span class="w"> </span><span class="n">meshCut</span><span class="p">,</span><span class="w"> </span><span class="n">cutUVRot</span><span class="w"> </span><span class="p">,</span><span class="n">cornerWholeUV</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">intData</span><span class="p">.</span><span class="n">integralSeamless</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">directional</span><span class="o">::</span><span class="n">integrate</span><span class="p">(</span><span class="n">combedField</span><span class="p">,</span><span class="w">  </span><span class="n">intData</span><span class="p">,</span><span class="w"> </span><span class="n">meshCut</span><span class="p">,</span><span class="w"> </span><span class="n">cutUVFull</span><span class="p">,</span><span class="n">cornerWholeUV</span><span class="p">);</span>
</code></pre></div>
<p>The data structure containing all relevant information about the integration is <code>IntegrationData</code>. It contains some parameters that can be tuned to control the integration. Several relevant ones are:</p>
<div class="highlight"><pre><span></span><code><span class="kt">double</span><span class="w"> </span><span class="n">lengthRatio</span><span class="p">;</span><span class="w">     </span><span class="c1">//global scaling of functions</span>
<span class="c1">//Flags</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">integralSeamless</span><span class="p">;</span><span class="w">  </span><span class="c1">//Whether to do full translational seamless.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">roundSeams</span><span class="p">;</span><span class="w">        </span><span class="c1">//Whether to round seams or round singularities</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">verbose</span><span class="p">;</span><span class="w">           </span><span class="c1">//output the integration log.</span>
</code></pre></div>
<p><code>lengthRatio</code> encodes a global scale for the Poisson problem (scaling the fields uniformly), where the ratio is measured against the bounding box diagonal. Some of the other parameters are demonstrated in the other examples in this chapter. The integrator takes the original (whole) mesh, and generates a cut-mesh (in <code>VMeshCut,FMeshCut</code>) of disc-topology. The singularities are on the boundary of this mesh, and the function can consequently be defined without branching ambiguity on its vertices, with the appropriate permutation and translation across the cut seams.</p>
<p><img alt="Example 501" src="../images/501_SeamlessIntegration.png" /><p align=center><em>Left: directional field. Center: permutationally-seamless integration. Right: fully-seamless integration.</em></p></p>
<h3 id="502-integration-in-various-orders">502 Integration in various orders<a class="headerlink" href="#502-integration-in-various-orders" title="Permanent link">&para;</a></h3>
<p>Directional can handle integration for every <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>, including less common ones like the non-periodic <span class="arithmatex"><span class="MathJax_Preview">N \neq 2,3,4,6</span><script type="math/tex">N \neq 2,3,4,6</script></span>. The properties of fields and integration in such unconventional <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> are explored in [<a href="#Meekes2021">Meekes and Vaxman 2021</a>].</p>
<p>In this example, we demonstrate the results for <span class="arithmatex"><span class="MathJax_Preview">N=2,4,7,11</span><script type="math/tex">N=2,4,7,11</script></span>, for the same <code>lengthRatio</code>. All are fully seamless. Note that the density of the isolines increases with <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>, and that we round the singularity function values, leading to junctions of multiple isolines meeting.  </p>
<p><img alt="Example 502" src="../images/502_DifferentOrders.png" /><p align=center><em>Left to right: <span class="arithmatex"><span class="MathJax_Preview">N=2,4,7,11</span><script type="math/tex">N=2,4,7,11</script></span>. Top: field. Bottom: integer isolines.</em></p></p>
<h3 id="503-rounding-either-seams-or-singularities">503 Rounding either seams or singularities<a class="headerlink" href="#503-rounding-either-seams-or-singularities" title="Permanent link">&para;</a></h3>
<p>It is possible to choose whether to round the seam jumps <span class="arithmatex"><span class="MathJax_Preview">T_e \in \mathbb{Z}^N</span><script type="math/tex">T_e \in \mathbb{Z}^N</script></span> directly, or the function values around singularities (and of topological handles, in case of non-simply-connected topology). In both cases, the seams will have integer values, but the latter case is more restrictive and will result in multiple isolines meeting at every singularity. For quad meshes with <span class="arithmatex"><span class="MathJax_Preview">N=4</span><script type="math/tex">N=4</script></span>, for instance, this is the difference between pure-quad results (round singularities), or just quad-dominant (round seams).</p>
<p><img alt="Example 503" src="../images/503_SeamsSingsRounding.png" /><p align=center><em>Left to right (bottom is zoom-in of top): Field, rounding only seams (leading to the top singularity being offset), and rounding singularity function values directly.]</em></p></p>
<h3 id="504-linear-reductions">504 Linear Reductions<a class="headerlink" href="#504-linear-reductions" title="Permanent link">&para;</a></h3>
<p>It is possible to constrain the functions to have linear relations between them, which reduce the degrees of freedom. This is done by inputting a matrix <span class="arithmatex"><span class="MathJax_Preview">U: N \times n</span><script type="math/tex">U: N \times n</script></span> so that <span class="arithmatex"><span class="MathJax_Preview">n \leq N</span><script type="math/tex">n \leq N</script></span>, and where <span class="arithmatex"><span class="MathJax_Preview">F = U\cdot f</span><script type="math/tex">F = U\cdot f</script></span> for the independent degrees of freedom encoded in <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>. This relationship should be mirrored in the integrated directional field. <em>Warning</em>: not every linear reduction is suitable for integration on surfaces! it needs to commute with the permutation around singularities. Feeding an incompatible linear reduction might then result in a failure of the algorithm. One popular example is triangular symmetry where <span class="arithmatex"><span class="MathJax_Preview">U_{3 \times 2} = [1, 0; 0, 1; -1, -1]</span><script type="math/tex">U_{3 \times 2} = [1, 0; 0, 1; -1, -1]</script></span>. Another is sign symmetry where <span class="arithmatex"><span class="MathJax_Preview">U = [Id_{n \times n}; -Id_{n \times n}]</span><script type="math/tex">U = [Id_{n \times n}; -Id_{n \times n}]</script></span>, and <span class="arithmatex"><span class="MathJax_Preview">n = \frac{N}{2}</span><script type="math/tex">n = \frac{N}{2}</script></span>. The latter is always assumed when <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> is even, and both are always valid in any singularity configuration. Symmetries can also be combined. <span class="arithmatex"><span class="MathJax_Preview">U</span><script type="math/tex">U</script></span> is fed into <code>intData</code> through the field <code>linRed</code>, and there are pre-made funtcions to set it, such as <code>set_triangular_symmetry(int N)</code>.</p>
<p><img alt="Example 504" src="../images/504_LinearReductions.png" /><p align=center><em>Top: A <span class="arithmatex"><span class="MathJax_Preview">6</span><script type="math/tex">6</script></span>-directional fields with a singularity. Bottom left: <span class="arithmatex"><span class="MathJax_Preview">N=6</span><script type="math/tex">N=6</script></span> only sign symmetry is enforced (the three lines don&rsquo;t always meet at all intersections). Right: the same with added triangular symmetry, where all lines intersect.</em></p></p>
<h3 id="505-meshing">505 Meshing<a class="headerlink" href="#505-meshing" title="Permanent link">&para;</a></h3>
<p>This subchapter demonstrates how we can create an actual polygonal mesh from the arrangement of isolines on the surface. This creates an arrangement of lines (in exact numbers) on every triangle, and stitches them together across triangles to get a complete conforming mesh. The new mesh is given in the <a href=https://avaxman.github.io/libhedra/>libhedra</a> format of <span class="arithmatex"><span class="MathJax_Preview">(V,D,F)</span><script type="math/tex">(V,D,F)</script></span>, where <span class="arithmatex"><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span> is a vector <span class="arithmatex"><span class="MathJax_Preview">|F| \times 1</span><script type="math/tex">|F| \times 1</script></span> of face degrees, and <span class="arithmatex"><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">|F| \times max(D)</span><script type="math/tex">|F| \times max(D)</script></span> matrix of indices into <span class="arithmatex"><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>.</p>
<p>The meshing unit is independent from the integration unit, and can be potentially used with external functions. However, it is easy to pipeline iit with the integration as follows:
<div class="highlight"><pre><span></span><code><span class="c1">//setting up mesh data from integration data</span>
<span class="n">directional</span><span class="o">::</span><span class="n">MesherData</span><span class="w"> </span><span class="n">mData</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">setup_mesher</span><span class="p">(</span><span class="n">meshCut</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">intData</span><span class="p">,</span><span class="w"> </span><span class="n">mData</span><span class="p">);</span>

<span class="c1">//meshing and saving</span>
<span class="n">mData</span><span class="p">.</span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Meshing N=&quot;</span><span class="o">&lt;&lt;</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">mesher</span><span class="p">(</span><span class="n">meshWhole</span><span class="p">,</span><span class="w"> </span><span class="n">mData</span><span class="p">,</span><span class="w"> </span><span class="n">VPolyMesh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">DPolyMesh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">FPolyMesh</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Done!&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></p>
<p>This reads the integrated information from <code>intData</code>. Conversely to previous version, the mesher does not necessarily need an external dependency. Nevertheless, it can optionally be sped up (considerably) by including <a href=https://gmplib.org/>GMP</a>. This is controlled by CMake within the compilation of the tutorial.</p>
<p><img alt="Example 505" src="../images/505_Meshing.png" /><p align=center><em>Left to right: polygonal meshes of the arrangements of isolines from the N=4,7,11 examples (<span class="arithmatex"><span class="MathJax_Preview">N=2</span><script type="math/tex">N=2</script></span> is not yet supported) in <a href="#502-integration-in-various-orders">Example 502</a>.</em></p></p>
<h2 id="chapter-6-cochain-complexes">Chapter 6: Cochain Complexes<a class="headerlink" href="#chapter-6-cochain-complexes" title="Permanent link">&para;</a></h2>
<p>Directional fields, and differential forms, are objects of differential geometry where the underlying manifold is equipped with notions of gradient, curl, divergence, and where gradient fields are curl free and cogradient fields (or just &ldquo;curl fields&rdquo;) are divergence free. These are special cases of the more abstract algebraic notion of <em>cochain complexes</em>. Without going into the full formality, such a complex is defined by a series of spaces <span class="arithmatex"><span class="MathJax_Preview">\Omega_i</span><script type="math/tex">\Omega_i</script></span>,  <span class="arithmatex"><span class="MathJax_Preview">0 \leq i \leq d</span><script type="math/tex">0 \leq i \leq d</script></span>, for some dimension <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>, which are related by differential operators <span class="arithmatex"><span class="MathJax_Preview">d_i:\Omega_i\rightarrow \Omega_{i+1}</span><script type="math/tex">d_i:\Omega_i\rightarrow \Omega_{i+1}</script></span>. These spaces can be equipped with a metric <span class="arithmatex"><span class="MathJax_Preview">&lt;&gt;_i:\Omega_i \times \Omega_i \rightarrow \mathbb{R}^{+}</span><script type="math/tex"><>_i:\Omega_i \times \Omega_i \rightarrow \mathbb{R}^{+}</script></span>. Essential to the definition is that <span class="arithmatex"><span class="MathJax_Preview">d_{i+1}d_i=0</span><script type="math/tex">d_{i+1}d_i=0</script></span>. For instance, scalars to vectors by the gradient operator, and then vectors to scalars (in 2D) by the curl operators comprise a cochain complex. A cochain complex also defines <span class="arithmatex"><span class="MathJax_Preview">i^{th}</span><script type="math/tex">i^{th}</script></span> singular cohomologies, which are the quotient spaces <span class="arithmatex"><span class="MathJax_Preview">\mathbb{H}_{i}=ker(d_{i})/im(d_{i-1})</span><script type="math/tex">\mathbb{H}_{i}=ker(d_{i})/im(d_{i-1})</script></span>. These only arise in case of nontrivial topology, and <span class="arithmatex"><span class="MathJax_Preview">|\mathbb{H}_i|=\beta_i</span><script type="math/tex">|\mathbb{H}_i|=\beta_i</script></span> are called the <em>Betti numbers</em>, which are in fact generators of the topology. The fields in these spaces are called <em>harmonic</em>. The metric also defines a Hodge star <span class="arithmatex"><span class="MathJax_Preview">\star_i: \Omega_i\rightarrow\Omega_{d-i}</span><script type="math/tex">\star_i: \Omega_i\rightarrow\Omega_{d-i}</script></span>, which is a duality relation; that often defines a dual cochain with a <em>codifferential</em> operator <span class="arithmatex"><span class="MathJax_Preview">\delta_i = (-1)^i\star_i^{-1}d_i^T\star_{i+1}</span><script type="math/tex">\delta_i = (-1)^i\star_i^{-1}d_i^T\star_{i+1}</script></span>.</p>
<p><strong>Example</strong>: All gradient fields are curl free, but there are only curl-free fields that are not also gradient in topologies like annuli or tori. the torus has genus <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> and admits two harmonic fields.</p>
<p>In the discrete setting, the spaces are represented as arrays of nodal values in some finite space, the <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> operators are (often sparse) matrices, and the metrics are implemented as symmetric positive matrices <span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> so that <span class="arithmatex"><span class="MathJax_Preview">&lt;a,b&gt;_i = a^TM_ib</span><script type="math/tex"><a,b>_i = a^TM_ib</script></span>. The hodge star is then simply a multiplication by <span class="arithmatex"><span class="MathJax_Preview">M_i</span><script type="math/tex">M_i</script></span>. However, it is often that this defines a separate dual structure rather then result in an object of the same space.</p>
<p>Although abstract, the notion has multiple concrete manifestations in directional field processing, which we explore through the chapters examples.</p>
<h3 id="601-face-based-finite-elements">601 Face-Based Finite Elements<a class="headerlink" href="#601-face-based-finite-elements" title="Permanent link">&para;</a></h3>
<p>What is called &ldquo;face-based FEM&rdquo; is in fact just the structure with face-based vectors depicted in the following figure:
<img alt="Example 6-1" src="images/601_FaceBasedFEM_complex.png" /><p align=center><em>Top: the primal cochain complex, taking conforming piecewise linear (PL) functions to face-based piecewise-constant fields, and the curl operator takes the latter to edge-based diamond regions. In the bottom dual structure (right to left), the rotated cogradient of non-conforming piecewise-linear functions are also piecewise-constant fields. their divergence is defined on dual vertex voronoi areas. Going from PL functions to dual regions is done by the mass matrices <span class="arithmatex"><span class="MathJax_Preview">M_v</span><script type="math/tex">M_v</script></span> and <span class="arithmatex"><span class="MathJax_Preview">M_e</span><script type="math/tex">M_e</script></span>. The face rotation operator <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span> simply rotates a vector by <span class="arithmatex"><span class="MathJax_Preview">\frac{\pi}{2}</span><script type="math/tex">\frac{\pi}{2}</script></span> in a face. The cochain structure is actually such that <span class="arithmatex"><span class="MathJax_Preview">CG_v=0</span><script type="math/tex">CG_v=0</script></span>, and the matching dual cochain structure <span class="arithmatex"><span class="MathJax_Preview">DJG_e=0</span><script type="math/tex">DJG_e=0</script></span> </em></p></p>
<p>Which is popular in geometry processing (for instance, studied extensively in [<a href="#Wardetzky2007">Wardetzky 2007</a>]. This is exemplified in the following code:
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Gv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">conf_gradient_matrix_2D</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Ge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">non_conf_gradient_matrix_2D</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">directional</span><span class="o">::</span><span class="n">face_vector_rotation_matrix_2D</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="err"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">curl_matrix_2D</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">div_matrix_2D</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
</code></pre></div>
<code>Ge</code> is the non-conforming (Edge-based) cogradient, and <code>J</code> is the in-face rotation matrix. The code proceeds by verifying the cochain relations (discrete curl of gradient and divergence of rotated cogradient):</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;max abs curl of exact field (should be numerically zero): &quot;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">Gv</span><span class="o">*</span><span class="n">confVec</span><span class="p">).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;max abs divergence of coexact field (should be numerically zero): &quot;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">Ge</span><span class="o">*</span><span class="n">nonConfVec</span><span class="p">).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p><img alt="Example 6-1" src="../images/601_FaceBasedFEM.png" /><p align=center><em>Left: a conforming PL function with its gradient. Right: a non-conforming PL function with its rotated cogradient.</em></p></p>
<h3 id="602-discrete-exterior-calculus">602 Discrete Exterior Calculus<a class="headerlink" href="#602-discrete-exterior-calculus" title="Permanent link">&para;</a></h3>
<p>DEC [<a href="#Desbrun2005">Desbrun et al. 2005</a>] is primarily working with differential forms rather than vector fields. As such, it decouples metric from differentials. In the discrete setting, <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>-forms (Scalar functions) are represented on vertices, <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-forms (the equivalent of tangent vector fields) as differentials on oriented edges, and <span class="arithmatex"><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>-forms (volume forms in 2D) as numbers on faces indicating an integrated quantity. The Hodge star defines a duality to the dual Voronoi mesh, as in the following diagram:</p>
<p><img alt="Example 6-2 structure" src="../images/602_DiscreteExteriorCalculus_Complex.png" /><p align=center><em>Top: the primal complex, where <span class="arithmatex"><span class="MathJax_Preview">d_0</span><script type="math/tex">d_0</script></span> is the differential (EQuivalent of gradient), <span class="arithmatex"><span class="MathJax_Preview">d_1</span><script type="math/tex">d_1</script></span> is the equivalent of curl, and their adjoints (up to Hodge duality) are the equivalents of rotated cogradient and divergence.</em></p></p>
<p>The <em>sharp</em> operator converts the discrete forms into their continuous counterparts, which in the PL case are Whitney forms (for instance, for <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>-forms it&rsquo;s just PL functions, as illustrated above). These can be used to create the mass matrices <span class="arithmatex"><span class="MathJax_Preview">M_0,M_1,M_2</span><script type="math/tex">M_0,M_1,M_2</script></span> to be served as Hodge stars. However, it is sometimes preferred to lump <span class="arithmatex"><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> to the primal/dual hodge star <span class="arithmatex"><span class="MathJax_Preview">\star_1</span><script type="math/tex">\star_1</script></span>, since it provides an easy inverse, albeit less accurate in some interpretations. Directional offers both options:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">d0_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">directional</span><span class="o">::</span><span class="n">d1_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hodgeStar</span><span class="p">,</span><span class="w"> </span><span class="n">invHodgeStar</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">hodge_star_1_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="n">hodgeStar</span><span class="p">,</span><span class="w"> </span><span class="n">invHodgeStar</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">M1</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">linear_whitney_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">);</span>

<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d0</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">d0</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d0</span><span class="p">.</span><span class="n">adjoint</span><span class="p">()</span><span class="o">*</span><span class="n">hodgeStar</span><span class="o">*</span><span class="n">d0</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L1</span><span class="o">-</span><span class="n">L2</span><span class="p">;</span>

<span class="kt">double</span><span class="w"> </span><span class="n">maxAbsValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">diff</span><span class="p">.</span><span class="n">outerSize</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">InnerIterator</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">        </span><span class="n">maxAbsValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxAbsValue</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">()));</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Exact laplacian identity (should be numerically zero): &quot;</span><span class="o">&lt;&lt;</span><span class="n">maxAbsValue</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">project_exact</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">hodgeStar</span><span class="p">,</span><span class="w"> </span><span class="n">z2</span><span class="p">,</span><span class="w"> </span><span class="n">z1Diag</span><span class="p">,</span><span class="w"> </span><span class="n">z2Exact</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Reproducing the original curl (z2Diag, should be numerically zero): &quot;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">z2</span><span class="o">-</span><span class="n">z2Exact</span><span class="p">).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">project_exact</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">z2</span><span class="p">,</span><span class="w"> </span><span class="n">z1</span><span class="p">,</span><span class="w"> </span><span class="n">z2Exact</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Reproducing the original curl (z2, should be numerically zero): &quot;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">z2</span><span class="o">-</span><span class="n">z2Exact</span><span class="p">).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Difference between z1 and z1Diag (small, not zero): &quot;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z1Diag</span><span class="p">).</span><span class="n">cwiseAbs</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p>The differences will only be culminated in the last <code>z1</code> vs. <code>z1Diag</code>. Other than the functions to construct the operators, this also introduces the <code>project_exact()</code> function which we discuss in the next tutorial example.</p>
<p><img alt="Example 6-2" src="../images/602_DiscreteExteriorCalculus.png" /><p align=center><em>Left: The reconstructed field with the Whitney <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-form mass matrix. Right: with the diagonal Hodge star. The visual difference in this case is mild.</em></p></p>
<h3 id="603-hodge-decomposition">603 Hodge Decomposition<a class="headerlink" href="#603-hodge-decomposition" title="Permanent link">&para;</a></h3>
<p>The combination of a cochain complex and metric introduces the Hodge decomposition, where we can also define the codifferential <span class="arithmatex"><span class="MathJax_Preview">\delta_i = (-1)^i\star_i^{-1}d_{i}^T\star_{i+1}</span><script type="math/tex">\delta_i = (-1)^i\star_i^{-1}d_{i}^T\star_{i+1}</script></span>. Every <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-form <span class="arithmatex"><span class="MathJax_Preview">z_i \in \Omega_i, 1\leq i \leq n-1</span><script type="math/tex">z_i \in \Omega_i, 1\leq i \leq n-1</script></span> can be decomposed as:
$$
z_i = d_{i-1}f_{i-1}+\delta_i g_{i+1} + h_i,
$$
where <span class="arithmatex"><span class="MathJax_Preview">f_{i-1}</span><script type="math/tex">f_{i-1}</script></span> is an <span class="arithmatex"><span class="MathJax_Preview">(i-1)</span><script type="math/tex">(i-1)</script></span>-form, <span class="arithmatex"><span class="MathJax_Preview">g_{i+1}</span><script type="math/tex">g_{i+1}</script></span> is an <span class="arithmatex"><span class="MathJax_Preview">(i+1)</span><script type="math/tex">(i+1)</script></span>-form, and <span class="arithmatex"><span class="MathJax_Preview">h_i \in \mathbb{H}_i</span><script type="math/tex">h_i \in \mathbb{H}_i</script></span> is a harmonic <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-form.  <span class="arithmatex"><span class="MathJax_Preview">z_\text{exact}=d_{i-1}f_{i-1}</span><script type="math/tex">z_\text{exact}=d_{i-1}f_{i-1}</script></span> is the <em>exact</em> component, and <span class="arithmatex"><span class="MathJax_Preview">z_\text{coexact}=\delta_{i+1}g_{i+1}</span><script type="math/tex">z_\text{coexact}=\delta_{i+1}g_{i+1}</script></span> is the <em>coexact</em> component. The exact, coexact and harmonic compoennts are always unique; however, <span class="arithmatex"><span class="MathJax_Preview">f,g</span><script type="math/tex">f,g</script></span> (the potentials) might not be, and one might need to further constrain them.. The existence of boundaries makes the problem even more intricate, as we discuss in Example 604.</p>
<p>Hodge decomposition in directional is done by the function <code>Hodge_decomposition()</code>. To understand how it works, we need to examine its implementation:</p>
<div class="highlight"><pre><span></span><code><span class="n">project_exact</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">cochain</span><span class="p">,</span><span class="w"> </span><span class="n">prevCochain</span><span class="p">,</span><span class="w"> </span><span class="n">exactCochain</span><span class="p">);</span>
<span class="n">project_coexact</span><span class="p">(</span><span class="n">dNext</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">MNext</span><span class="p">,</span><span class="w"> </span><span class="n">cochain</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">coexactCochain</span><span class="p">,</span><span class="w"> </span><span class="n">nextCochain</span><span class="p">);</span>
<span class="n">harmCochain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cochain</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">exactCochain</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">coexactCochain</span><span class="p">;</span>
</code></pre></div>
<p><code>project_exact()</code> finds <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> and consequently the exact part. In case <span class="arithmatex"><span class="MathJax_Preview">d_0</span><script type="math/tex">d_0</script></span> has a trivial null-space, the default option its to solve the Poisson equation:
$$
f = \text{argmin}|d_{i-1} f - z_i|^2.
$$
The least-squares solution is obtained where:
$$
d_{i-1}^T\star_i d_{i-1}f = d_{i-1}^T\star_i z_i
$$</p>
<p>In case <span class="arithmatex"><span class="MathJax_Preview">d_i</span><script type="math/tex">d_i</script></span> has a meaningful null-space (for instance, when it is part of a longer ccochain complex, and <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> itself has a non-trivial Hodge decomposition), one should instead opt for a <em>Gauge-fixing solution</em>, where we solve for the minimum <span class="arithmatex"><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>-norm solution:
$$
f = \text{argmin}|f|<sup>2  s.t.  d_{i-1}</sup>T\star_i  d_{i-1}f = d_{i-1}^T\star_i z_i.
$$ </p>
<p>In terms of code arguments, <code>d</code> is <span class="arithmatex"><span class="MathJax_Preview">d_{i-1}</span><script type="math/tex">d_{i-1}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> is <span class="arithmatex"><span class="MathJax_Preview">\star_i</span><script type="math/tex">\star_i</script></span>, <code>prevCochain</code> is <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> and <code>exactCochain</code> is <span class="arithmatex"><span class="MathJax_Preview">d_{i-1}f</span><script type="math/tex">d_{i-1}f</script></span>. Fixing Gauge is controlled by a <code>GagueFixing</code> flag and is by default <code>False</code>.</p>
<p><code>project_coexact()</code> is simpler, as it just computes:
$$
z_\text{coexact} = \text{argmin}|z_\text{coexact}|^2  s.t.  d_iz_\text{coexact} = d_iz_{i}
$$
This amount to an orthogonal projection of <span class="arithmatex"><span class="MathJax_Preview">z_i</span><script type="math/tex">z_i</script></span> to the space of coexact forms. Interestingly, the Lagrange multipler of this contraint is exactly the desired potential <span class="arithmatex"><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span>.</p>
<p><img alt="Example 6-3" src="../images/603_HodgeDecomposition.png" /><p align=center><em>Top: a piecewise-constant face-based vector field. Bottom: its decomposition into exact, coexact, and harmonic forms. The colors indicate the potential fields (left <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> and middle <span class="arithmatex"><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span>).
</em></p></p>
<h3 id="604-hodge-decomposition-with-boundaries">604 Hodge decomposition with boundaries<a class="headerlink" href="#604-hodge-decomposition-with-boundaries" title="Permanent link">&para;</a></h3>
<p>In the case of boundaries, <span class="arithmatex"><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> and <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> are not adjoint anymore without setting explicit boundary conditions. These can be intricate in higher dimensions, but in 2D surfaces can usually be the choice between Dirichlet or Neumann. This culminates in the construction of the operators themselves. For instance:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">NumberType</span><span class="o">&gt;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="n">NumberType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d0_matrix</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TriMesh</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mesh</span><span class="p">,</span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDirichlet</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span>
</code></pre></div>
Currently only Neumann conditions are implemeneted for DEC; that means that the exact component of the Hodge decomposition is free, whereas the coexact and the harmonic components are tangent the the boundaries.</p>
<p><img alt="Example 6-4" src="../images/604_HodgeBoundary.png" /><p align=center><em>Top: a <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-form. Bottom: its decomposition into exact, coexact, and harmonic forms with Neumann boundary conditions (coexact and harmonic are tangent to the boundaries). The colors indicate the potential field (left <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> and middle <span class="arithmatex"><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span>).
</em></p></p>
<h3 id="605-harmonic-fields">605 Harmonic Fields<a class="headerlink" href="#605-harmonic-fields" title="Permanent link">&para;</a></h3>
<p>it is possible to enumerate the harmonic fields as the null-space independent vectors (cohmology) of the harmonic operator. This is obtained through <code>cohomology_basis()</code>.</p>
<p><img alt="Example 6-4" src="../images/605_HarmonicFields.png" /><p align=center><em>Two example of harmonic fields. They are naturally associated to homologies (handles) of the surface.
</em></p></p>
<!-- 
A *cochain complex* is defined by a gradient operator $G$ and a curl operator $C$ where $C \cdot G=0$. 

The "cochain" aspect can be purely algebraic and not rely on any explicit nodes in $G_{TB}$; we call $G\cdot f$ for any "scalar" function $f$ *exact* (or *conservative*) fields and fields where $C\cdot v=0$ *closed* (or *curl-free*) fields. 

A cochain complex is enough to define *deRham cohomology* with the correct dimensions $ker(C)/im(G)$. However to extract the explicit harmonic fields we need the next property. 

The combination of a metric and a cochain complex allows for a well-defined notion of *Helmholtz-Hodge decomposition*: any vector field $v$ can be decomposed into exact part $Gf$, coexact part $M^{-1}C^Tg$ and harmonic part $h$ as follows [~boksebeld_2022]:

$$v = Gf + M^{-1}C^Tg + h$$

The inner product also introduces the discrete divergence operator $G^T\cdot M$. Note that the coexact part is divergence free since $G^T\cdot C^T = 0$. The harmonic part $h$ is both.
-->

<h2 id="outlook-for-continuing-development">Outlook for continuing development<a class="headerlink" href="#outlook-for-continuing-development" title="Permanent link">&para;</a></h2>
<p>Directional is a an ever-evolving project, and there are many algorithms in the state-of-the-art that we look forward to implement, with the help of volunteer researchers and practitioners from the field. Prominent examples of desired implementations are:</p>
<ol>
<li>
<p>Support for 3D fields, particularly <em>Octahedral</em> fields [^solomon_2017], both in tet meshes and with the boundary-element method.</p>
</li>
<li>
<p>Support for tensor fields.</p>
</li>
<li>
<p>Higher-order fields.</p>
</li>
</ol>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p><a id="Azencot2017"></a>Azencot et al., 2017
: Omri Azencot, Etienne Corman, Mirela Ben-Chen, Maks Ovsjanikov, Consistent Functional Cross Field Design for Mesh Quadrangulation.</p>
<p><a id="Bommes2009"></a>Bommes et al., 2009
: David Bommes, Henrik Zimmer, Leif Kobbelt, Mixed-integer quadrangulation.</p>
<p><a id="Bommes2012"></a>Bommes et al., 2012
: David Bommes, Henrik Zimmer, Leif Kobbelt, Practical Mixed-Integer Optimization for Geometry Processing.</p>
<p><a id="Bouaziz2012"></a>Bouaziz et al., 2012
: Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly, Shape-Up: Shaping Discrete Geometry with Projections.</p>
<p><a id="Brandt2018"></a>Brandt et al., 2018
: Christopher Brandt, Leonardo Scandolo, Elmar Eisemann, Klaus Hildebrandt, Modeling n-Symmetry Vector Fields using Higher-Order Energies.</p>
<p><a id="Crane2010"></a>Crane et al., 2010
: Keenan Crane, Mathieu Desbrun, Peter Schrder, Trivial Connections on Discrete Surfaces.</p>
<p><a id="CignoniMeshlab"></a>Cignoni et al., Meshlab
: Paolo Cignoni, Marco Callieri, Massimiliano Corsini, Matteo Dellepiane, Fabio Ganovelli, Guido Ranzuglia, MeshLab: an Open-Source Mesh Processing Tool.</p>
<p><a id="Custers2020"></a>Custers &amp; Vaxman, 2020
: Bram Custers, Amir Vaxman, Subdivision Directional Fields.</p>
<p><a id="Desbrun2005"></a>Desbrun et al., 2005
: Discrete Differential Forms for Computational Modeling.</p>
<p><a id="Diamanti2014"></a>Diamanti et al., 2014
: Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Designing N-PolyVector Fields with Complex Polynomials.</p>
<p><a id="Diamanti2015"></a>Diamanti et al., 2015
: Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Integrable PolyVector Fields.</p>
<p><a id="deGoes2016"></a>de Goes et al., 2016
: Fernando de Goes, Mathieu Desbrun, Yiying Tong, Vector Field Processing on Triangle Meshes.</p>
<p><a id="Klberer2007"></a>Klberer et al., 2007
: Felix Klberer, Matthias Nieser, Konrad Polthier, QuadCover - Surface Parameterization using Branched Coverings.</p>
<p><a id="Knoeppel2013"></a>Knppel et al., 2013
: Felix Knppel, Keenan Crane, Ulrich Pinkall, Peter Schrder, Globally Optimal Direction Fields.</p>
<p><a id="Liu2011"></a>Liu et al., 2008
: Yang Liu, Weiwei Xu, Jun Wang, Lifeng Zhu, Baining Guo, Falai Chen, Guoping Wang, General Planar Quadrilateral Mesh Design Using Conjugate Direction Field.</p>
<p><a id="Myles2014"></a>Myles et al., 2014
: Ashish Myles, Nico Pietroni, Denis Zorin, Robust Field-aligned Global Parametrization.</p>
<p><a id="Meekes2021"></a>Meekes &amp; Vaxman, 2021
: Merel Meekes, Amir Vaxman, Unconventional Patterns on Surfaces.</p>
<p><a id="Panozzo2014"></a>Panozzo et al., 2014
: Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung, Frame Fields: Anisotropic and Non-Orthogonal Cross Fields.</p>
<p><a id="Ray2008"></a>Ray et al., 2008
: Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno Lvy, N-symmetry direction field design.</p>
<p><a id="Solomon2017"></a>Solomon et al., 2017
: Justin Solomon, Amir Vaxman, David Bommes, Boundary Element Octahedral Fields in Volumes.</p>
<p><a id="Vaxman2016"></a>Vaxman et al., 2016
: Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen, Directional Field Synthesis, Design, and Processing.</p>
<p><a id="Vaxman2021"></a>Vaxman, 2021
: Amir Vaxman, Directional Technical Reports: Seamless Integration.</p>
<p><a id="Viertel2017"></a>Viertel and Osting, 2017
: An Approach to Quad Meshing Based on Harmonic Cross-Valued Maps and the Ginzburg-Landau Theory.</p>
<p><a id = "Wang2023"></a>Wang et al., 2023 
: Stephanie Wang, Mohammad Sina Nabizadeh, Albert Chern, Exterior Calculus in Graphics.</p>
<p><a id="Wardetzky2007"></a>Wardetzky, 2007
: Max Wardetzky, Discrete differential operators on polyhedral surfaces-convergence and approximation.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/avaxman" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M202.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1M496 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2m-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3m-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": [], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>