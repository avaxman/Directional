{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Directional - A Directional-Field Processing Library \u00b6 https://github.com/avaxman/Directional/ Directional is a C++ library for creating, manipulating and visualizing directional fields on 3D meshes, built as an extension to libigl on the foundations of Eigen . Directional represents directional fields: discrete sets of vectors on meshes. The content and the notations are based on the Eurographics 2016 star (adapted subsequently to SIGGRAPH Asia 2016/SIGGRAPH 2017 courses) on Directional Field Synthesis, Design, and Processing . Some visualization code is borrowed from the libhedra library. Directional was called \u201clibdirectional\u201d until version 1.5. The name was shortened to avoid a clash with libDirectional . Installation \u00b6 Directional is a header-only library where each file generally includes one function. To use the library, simply add the include directory to your include path and make sure Directional and its prerequisites are set up properly. After that you can include any files you need normally, using for example #include <directional/index_prescription.h> . To get the library, simply clone the repository using: git clone --recursive https://github.com/avaxman/Directional.git Features \u00b6 The current version is 1.5, comprising the following features: Representation of per-face directional fields of any given degree and symmetry. Visualization using glyphs and streamline tracing. Principal and curl matching, and combing for N N -directional fields. Computation of power fields of N N -RoSy fields. PolyVector fields. Optimization for curl reduction. Conjugate fields. Prescription of singularity, generator, and boundary indices. Rotationally- and fully-seamless parameterization. Directional is a header-only library . You do not need to compile anything to use, just include directional headers (e.g. #include <directional/index_prescription.h> ) and run. Each header file contains a single function (e.g. igl/index_prescription.h contains igl::index_prescription() ). Tutorial \u00b6 A Tutorial that walks through the entire functionality of Directional is available. To compile it, go to the tutorial folder, open a shell and call: mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release ../ make This should properly set up the tutorial project, with the individual chapters as subprojects, and create project makefiles upon which you can build it using your favourite compiler. For windows, you should use cmake-gui .. and follow the instructions to create a compilable Visual Studio file. Coding Guidelines and Tips \u00b6 Directional inherits and follows the strict coding guidelines of libigl: please take a look here before submitting your pull requests. How to Contribute \u00b6 If you are interested in joining development, please fork the repository and submit a pull request with your changes. License \u00b6 Directional is primarily MPL2 licensed ( FAQ ). Some files contain third-party code under other licenses. Attribution \u00b6 If you use Directional in your academic projects, please cite the implemented papers directly, and/or the EG STAR 2016 when appropriate. To cite the library in general, you could use this BibTeX entry: @misc{Directional, author = {Amir Vaxman and others}, title = {{Directional: A library for Directional Field Synthesis, Design, and Processing}}, doi = {10.5281/zenodo.3338174}, url = {https://doi.org/10.5281/zenodo.3338174} } Contact \u00b6 Directional is led by Amir Vaxman . Please contact me if you have questions or comments. For troubleshooting, please post an issue on github. If you\u2019re using libirectional in your projects, quickly drop me a note . Tell me who you are and what you\u2019re using it for. This helps justify spending time maintaining this library! Future Plans \u00b6 The following functionality is still in workds for Directional: Other discretizations: discrete exterior calculus, vector-based fields. 3D fields. Discrete vector calculus: operators and Hodge decomposition. Line-integral convolution visualization. N-Symmetry seamless parameterization (for hexagonal and triangle remeshing). Subdivision fields. If you would like to suggest further topics, would like to collaborate in implementation, complain about bugs or ask questions, please address Amir Vaxman (or open an issue in the repository). Copyright \u00b6 2017 Amir Vaxman, Sam de Redelijkheid, Daniele Panozzo, Olga Diamanti, Olga Sorkine-Hornung, and others. Please see individual files for appropriate copyright notices.","title":"Home"},{"location":"#directional-a-directional-field-processing-library","text":"https://github.com/avaxman/Directional/ Directional is a C++ library for creating, manipulating and visualizing directional fields on 3D meshes, built as an extension to libigl on the foundations of Eigen . Directional represents directional fields: discrete sets of vectors on meshes. The content and the notations are based on the Eurographics 2016 star (adapted subsequently to SIGGRAPH Asia 2016/SIGGRAPH 2017 courses) on Directional Field Synthesis, Design, and Processing . Some visualization code is borrowed from the libhedra library. Directional was called \u201clibdirectional\u201d until version 1.5. The name was shortened to avoid a clash with libDirectional .","title":"Directional - A Directional-Field Processing Library"},{"location":"#installation","text":"Directional is a header-only library where each file generally includes one function. To use the library, simply add the include directory to your include path and make sure Directional and its prerequisites are set up properly. After that you can include any files you need normally, using for example #include <directional/index_prescription.h> . To get the library, simply clone the repository using: git clone --recursive https://github.com/avaxman/Directional.git","title":"Installation"},{"location":"#features","text":"The current version is 1.5, comprising the following features: Representation of per-face directional fields of any given degree and symmetry. Visualization using glyphs and streamline tracing. Principal and curl matching, and combing for N N -directional fields. Computation of power fields of N N -RoSy fields. PolyVector fields. Optimization for curl reduction. Conjugate fields. Prescription of singularity, generator, and boundary indices. Rotationally- and fully-seamless parameterization. Directional is a header-only library . You do not need to compile anything to use, just include directional headers (e.g. #include <directional/index_prescription.h> ) and run. Each header file contains a single function (e.g. igl/index_prescription.h contains igl::index_prescription() ).","title":"Features"},{"location":"#tutorial","text":"A Tutorial that walks through the entire functionality of Directional is available. To compile it, go to the tutorial folder, open a shell and call: mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release ../ make This should properly set up the tutorial project, with the individual chapters as subprojects, and create project makefiles upon which you can build it using your favourite compiler. For windows, you should use cmake-gui .. and follow the instructions to create a compilable Visual Studio file.","title":"Tutorial"},{"location":"#coding-guidelines-and-tips","text":"Directional inherits and follows the strict coding guidelines of libigl: please take a look here before submitting your pull requests.","title":"Coding Guidelines and Tips"},{"location":"#how-to-contribute","text":"If you are interested in joining development, please fork the repository and submit a pull request with your changes.","title":"How to Contribute"},{"location":"#license","text":"Directional is primarily MPL2 licensed ( FAQ ). Some files contain third-party code under other licenses.","title":"License"},{"location":"#attribution","text":"If you use Directional in your academic projects, please cite the implemented papers directly, and/or the EG STAR 2016 when appropriate. To cite the library in general, you could use this BibTeX entry: @misc{Directional, author = {Amir Vaxman and others}, title = {{Directional: A library for Directional Field Synthesis, Design, and Processing}}, doi = {10.5281/zenodo.3338174}, url = {https://doi.org/10.5281/zenodo.3338174} }","title":"Attribution"},{"location":"#contact","text":"Directional is led by Amir Vaxman . Please contact me if you have questions or comments. For troubleshooting, please post an issue on github. If you\u2019re using libirectional in your projects, quickly drop me a note . Tell me who you are and what you\u2019re using it for. This helps justify spending time maintaining this library!","title":"Contact"},{"location":"#future-plans","text":"The following functionality is still in workds for Directional: Other discretizations: discrete exterior calculus, vector-based fields. 3D fields. Discrete vector calculus: operators and Hodge decomposition. Line-integral convolution visualization. N-Symmetry seamless parameterization (for hexagonal and triangle remeshing). Subdivision fields. If you would like to suggest further topics, would like to collaborate in implementation, complain about bugs or ask questions, please address Amir Vaxman (or open an issue in the repository).","title":"Future Plans"},{"location":"#copyright","text":"2017 Amir Vaxman, Sam de Redelijkheid, Daniele Panozzo, Olga Diamanti, Olga Sorkine-Hornung, and others. Please see individual files for appropriate copyright notices.","title":"Copyright"},{"location":"RELEASE_HISTORY/","text":"Directional version tracking \u00b6 Version 1.5.0 Changes \u00b6 The major changes are: Change in name from \u201clibdirectional\u201d to \u201cDirectional\u201d. Full compatibility to the libigl 2.0 release, including similar website build and tutorial cmake paradigms. Introducing seamless parameterization. Rendering the different component of field visualization (mesh, field, streamlines, glyphs, singularities) as separate meshes, to facilitate coding. As a result, the \u201cappending\u201d options of directional::line_cylinders() etc. were removed. Visualization was canonicalized using directional\\visualization_schemes.h for a more homogeneous look. The tutorial portions imported from libigl (Conjugate fields, curl reduction, streamline tracing) are now fully compatible with Directional representation and data structures. Combing is now dependent on a given matching, and therefore there is no separate curl_combing() or principal_combing() . Functionality was renamed to better reflect its general application and target, rather then the name assigned by the relevant papers. Former Name New Name Integrable PolyVectors PolyCurl Reduction Trivial Connection Index prescription Globally Optimal Power FIelds Version 1.0 Changes \u00b6 Alpha version of Directional (then called \u201clibdirectional\u201d). Introducing the following functionality: Glyph Drawing with singularities. Trivial connection. Globally optimal fields. Polyvectors + integrable polyvectors. Principal matching and combing.","title":"Release History"},{"location":"RELEASE_HISTORY/#directional-version-tracking","text":"","title":"Directional version tracking"},{"location":"RELEASE_HISTORY/#version-150-changes","text":"The major changes are: Change in name from \u201clibdirectional\u201d to \u201cDirectional\u201d. Full compatibility to the libigl 2.0 release, including similar website build and tutorial cmake paradigms. Introducing seamless parameterization. Rendering the different component of field visualization (mesh, field, streamlines, glyphs, singularities) as separate meshes, to facilitate coding. As a result, the \u201cappending\u201d options of directional::line_cylinders() etc. were removed. Visualization was canonicalized using directional\\visualization_schemes.h for a more homogeneous look. The tutorial portions imported from libigl (Conjugate fields, curl reduction, streamline tracing) are now fully compatible with Directional representation and data structures. Combing is now dependent on a given matching, and therefore there is no separate curl_combing() or principal_combing() . Functionality was renamed to better reflect its general application and target, rather then the name assigned by the relevant papers. Former Name New Name Integrable PolyVectors PolyCurl Reduction Trivial Connection Index prescription Globally Optimal Power FIelds","title":"Version 1.5.0 Changes"},{"location":"RELEASE_HISTORY/#version-10-changes","text":"Alpha version of Directional (then called \u201clibdirectional\u201d). Introducing the following functionality: Glyph Drawing with singularities. Trivial connection. Globally optimal fields. Polyvectors + integrable polyvectors. Principal matching and combing.","title":"Version 1.0 Changes"},{"location":"file_formats/","text":"Directional file formats \u00b6 Raw Field ( .rawfield ) \u00b6 This file format describe a face-based field given in uncompressed xyz form as follows: [Degree] [#faces] [x] [y] [z] [x][y][z] .... N*Degree columns ... #faces rows The convention is that the vectors are assumed to be ordered by the given index within each face. Mostly expected to be CCW ordering around the normal for several functions. Altering this might result in unexpected results. The indices are not assumed to be matching across neighboring faces, and are independently indexed per face. Singularities ( .sing ) \u00b6 This file format describes prescribed singularities as follows: [Degree] [#singularities] [vertex_i] [index_i] ... #singularities rows Where index_i are integers, and the actual fractional index for vertex i i is \\frac{index_i}{Degree} \\frac{index_i}{Degree} . The indices can be negative and are considered unbounded if need be. Matching ( .matching ) \u00b6 This file format described the matching between each two neighboring faces i i and j j (across a dual edge: ([vertex_e], [vertex_f])) as follows: [Degree] [#dual_edges] [face_i] [face_j] [vertex_e] [vertex_f] [matching_k] ... #dual_edges rows The order is generally compatible with the result of the field EF in igl::edge_topology() for the same mesh, but that is not a guarantee. That means the vector k k in face i i is matched to vector k+matching_i k+matching_i (modulu Degree Degree ) in face j j , and the rest in an order-preserving manner. See tutorial for details. Data structures used from libigl \u00b6 .dmat uncompressed ASCII/binary files for dense matrices .off Geomview\u2019s polyhedral file format .obj Wavefront object file format. Usually unsafe to assume anything more than vertex positions and triangle indices are supported .png Portable Network Graphics image file. IGLLIB (in the libiglpng extra) supports png image files via the yimg library. Alpha channels and compression are supported.","title":"File Formats"},{"location":"file_formats/#directional-file-formats","text":"","title":"Directional file formats"},{"location":"file_formats/#raw-field-rawfield","text":"This file format describe a face-based field given in uncompressed xyz form as follows: [Degree] [#faces] [x] [y] [z] [x][y][z] .... N*Degree columns ... #faces rows The convention is that the vectors are assumed to be ordered by the given index within each face. Mostly expected to be CCW ordering around the normal for several functions. Altering this might result in unexpected results. The indices are not assumed to be matching across neighboring faces, and are independently indexed per face.","title":"Raw Field (.rawfield)"},{"location":"file_formats/#singularities-sing","text":"This file format describes prescribed singularities as follows: [Degree] [#singularities] [vertex_i] [index_i] ... #singularities rows Where index_i are integers, and the actual fractional index for vertex i i is \\frac{index_i}{Degree} \\frac{index_i}{Degree} . The indices can be negative and are considered unbounded if need be.","title":"Singularities (.sing)"},{"location":"file_formats/#matching-matching","text":"This file format described the matching between each two neighboring faces i i and j j (across a dual edge: ([vertex_e], [vertex_f])) as follows: [Degree] [#dual_edges] [face_i] [face_j] [vertex_e] [vertex_f] [matching_k] ... #dual_edges rows The order is generally compatible with the result of the field EF in igl::edge_topology() for the same mesh, but that is not a guarantee. That means the vector k k in face i i is matched to vector k+matching_i k+matching_i (modulu Degree Degree ) in face j j , and the rest in an order-preserving manner. See tutorial for details.","title":"Matching (.matching)"},{"location":"file_formats/#data-structures-used-from-libigl","text":".dmat uncompressed ASCII/binary files for dense matrices .off Geomview\u2019s polyhedral file format .obj Wavefront object file format. Usually unsafe to assume anything more than vertex positions and triangle indices are supported .png Portable Network Graphics image file. IGLLIB (in the libiglpng extra) supports png image files via the yimg library. Alpha channels and compression are supported.","title":"Data structures used from libigl"},{"location":"tutorial/","text":"Directional tutorial notes Introduction \u00b6 Directional is a C++ geometry processing library written as an extension library to libigl , with a specialization in directional-field processing. The functionality is based on the definitions and taxonomy surveyed theoretically in 16 , and through it by the relevant papers in the literature. It contains tools to edit, analyze, and visualize directional fields of various degrees and symmetries. The underlying structure extends the general philosophy of libigl : the library is header only, where each header contains a set of functions closely related (for instance, the precomputation and computation of some directional quantity over a mesh). For the most part, one header contains only one function. The data structures are, for the most part, simple matrices in Eigen , and the library avoids complicated and nested structures, relying instead on standalone functions. The visualization is done on the basis of libigl viewer, with some extended options that allow the rendering of directional fields. The header files contain documentation of the parameters to each function and their required composition; in this tutorial we will mostly tie the functionality of Directional to the theoretical concepts of directional fields and the methods to process them. Installing the tutorial examples \u00b6 This tutorial comprises an exhaustive set of examples that demonstrates the capabilities of Directional, where every subchapter entails a single concept. The tutorial code can be installed by going into the tutorial folder from the main Directional folder, and typing the following instructions in a terminal: mkdir build cd build cmake - DCMAKE_BUILD_TYPE = Release .. / make This will build all tutorial chapters in the build folder. The necessary dependencies will be appended and built automatically. To build in windows, use the cmake-gui .. options instead of the last two commands, and create the project using Visual Studio, with the proper tutorial subchapter as the \u201cstartup project\u201d. To access a single example, say 202_Sampling , go to the build subfolder, and the executable will be there. Command-line arguments are never required; the data is read from the shared folder directly for each example. Most examples require a modest amount of user interaction; the instructions of what to do are given in the command-line output upon execution. Discretization \u00b6 There are several ways to represent tangent planes on triangle meshes, although not all of them compatible with the different information that the fields convey. Mainstream discretizations roughly categorize into face-based, edge-based, and vertex-basex discretizations (see 8 for an in-depth analysis). The only discretization currently supported by Directional is that of tangent face-based fields, where the discrete tangent plane is taken to be the supporting plane to each (naturally flat) face. We also use a local basis (provided by igl::local_basis() ) to parameterize each tangent plane. Notions like connection, parallel transport, and consequently smoothness, are measured on dual edges between adjacent faces. Representation \u00b6 The representation of a directional field is the way it is encoded in each discrete tangent plane, and across adjacent tangent planes. Directional uses several different representations to describe directional fields. We denote the number of faces in the mesh as |F| |F| , the set of inner edges (adjacent to two triangles) as E_I E_I , and the degree of the field as N N (must be fixed for the entire field). The supported representations are as follows, where the taxonomy is based on that of the directional field course 16 : Raw - A |F|\\times 3N |F|\\times 3N double matrix, representing an 1^N 1^N -vector field (a directional with N N independent vectors in each face) in the form X_1, Y_1, Z_1, X_2, Y_2, Z_2, \\cdots X_N, Y_N, Z_N X_1, Y_1, Z_1, X_2, Y_2, Z_2, \\cdots X_N, Y_N, Z_N per face. Vectors are assumed to be ordered in counterclockwise order in most Directional functions that process raw fields. Representative . A |F| \\times 3 |F| \\times 3 double matrix that represents a rotationally symmetric N N -vector field, known as an N N -RoSy. The single vector is an arbitrary \u201cfirst\u201d vector in the face, and the rest of the vectors are deduced by rotations of \\frac{2\\cdot\\pi}{N} \\frac{2\\cdot\\pi}{N} . That means the all functions should also accept N N as input to decode the full field. Rotation Angles . A |E_I| |E_I| -sized double vector representing the rotation angle between two directions (without magnitude information) on two adjacent triangles. The rotation represents the deviation from the Levi-Civita parallel transport 5 , 11 . This representation may only encode N N -direction fields (no magnitude). Note that the effort (sum of all rotations) is then N N times rotation angles. Since this is a differential quantity, an extra global rotation needs to be given to uniquely decode the full face-based field. Power Field - An |F| |F| -sized complex vector, encoding an N N -RoSy object as a single complex number y=u^N y=u^N encoded in the local basis, where the N N -RoSy is the set of roots u \\cdot e^{\\frac{2\\pi i k}{N}}, k \\in [0,N-1] u \\cdot e^{\\frac{2\\pi i k}{N}}, k \\in [0,N-1] . The magnitude is also encoded this way, though it may be neglected in some applications. The representation depends on a local 2D 2D basis, such as one that could be obtained from igl::local_basis() . PolyVector - A |F| \\times N |F| \\times N complex matrix, representing the coefficients a a of a monic complex polynomial f(z)=z^N+\\sum_{i=0}^{N-1}{a_iz^i} f(z)=z^N+\\sum_{i=0}^{N-1}{a_iz^i} , which roots u u are the encoded 1^N 1^N -vector field. Every row is encoded as a_{0},\\cdots, a_{N-1} a_{0},\\cdots, a_{N-1} , where a_0 a_0 is the free coefficient. In case where the field is an N N -RoSy, all coefficients but a_0 a_0 are zero. Directional provides a number of conversion functions to switch between different representations. Each of the functions is of the form rep1_to_rep2 , where rep1 and rep2 are the representation names in the above list. e.g., rotation_to_representative() and polyvector_to_raw() . Some possible combinations are given by composing two functions in sequence. However, note that not every conversion is possible; for instance, it is not possible to convert between PolyVectors and rotation angles, as they do not possess the same power of expression (with current state-of-the-art\u2026). For N N -RoSy fields, for instance, you will most likely work primarily with the power field, representative, or rotation-angle representation. converting into the more explicit raw representation is often needed for I/O and visualization. Chapter 1: I/O and Visualization \u00b6 Visualization paradigm \u00b6 Directional uses the libigl viewer (although a viewer is not necessary for the core functionality), and augments it with auxiliary functionality and color schemes that pertain to directional fields specifically. The drawing paradigm in Directional is that the visualization functions create actual meshes (vertices, faces, and per-face colors) for the different components of the field: box-like meshes for per-face glyphs representing vectors, sphere meshes for representing singularities, piecewise-cylinder curves to represent streamlines, and more. These visualization meshes can then be stored in libigl viewer as multiple meshes and visualized as needed. The color schemes and directional visualization mesh creation functionality are mostly given in visualization_schemes.h , and can be called to create a homogeneous look for visualizing fields in applications. Most notable are indexed_glyph_colors() that gives back glyph meshes colored by index per face, and default_singularity_colors() that produces singularity meshes according to index. Other visualization functionality is detailed below in the context of the different examples. 101 Glyph Rendering \u00b6 The most basic operation on directional fields is reading them from a file and drawing them in the most explicit way. In Example 101 , a field is read from a file as follows: directional :: read_raw_field ( TUTORIAL_SHARED_PATH \"/bumpy.rawfield\" , N , rawField ); directional :: read_singularities ( TUTORIAL_SHARED_PATH \"/bumpy.sings\" , N , singVertices , singIndices ); The field is read in raw format (see File Formats ), which is detailed in the Introduction . The field is face-based , and the singularities are consequently vertex-based , where singVertices are the singular vertices, and singIndices are the corresponding integer indices, so that the actual fractional indices are \\frac{singIndices}{N} \\frac{singIndices}{N} . The visualization meshes for the glyphs and the singularities are obtained as follows directional :: glyph_lines_raw ( VMesh , FMesh , rawField , directional :: default_glyph_color (), VField , FField , CField ); directional :: singularity_spheres ( VMesh , FMesh , N , singVertices , singIndices , VSings , FSings , CSings ); These two operations do not produce any active drawing; they create meshes that extend the original geometry, and then get passed to libigl viewer. directional::glyph_lines_raw() creates box-like meshes on the faces that constitute the glyph drawing : simply drawing the vectors upon the faces in their \\left(x,y,z\\right) \\left(x,y,z\\right) coordinates, starting from the face barycenter. There are several possibilities to color these vectors, which can be local or global; check the documentation to the function in the header. In this case, we give the default_glyph_color() from the Directional visualization schemes. Vectors are drawn in their given magnitudes, up to a global scale. By default, this scale is set to be related to the average edge length\u2014it can be manually set by all visualization-mesh-creating function. directional::singularity_spheres() creates a mesh of small spheres on vertices, where the size of the sphere is devised by default. The spheres are only created where the index is different than 0 0 . Example 101 Glyph Rendering on a mesh, with singularities visible. 102 Picking and editing \u00b6 This example demonstrates the editing paradigm in Directional, based on libigl picking. A face and a vector within the face are chosen, and clicking on a new direction for the vector changes it. Note the different setting of colors for glyphs: for the selected face and for the selected vector in the face particularly, via the following code in Example 102 . Eigen :: MatrixXd glyphColors = directional :: default_glyph_color (). replicate ( FMesh . rows (), N ); glyphColors . row ( currF ) = directional :: selected_face_glyph_color (). replicate ( 1 , N ); glyphColors . block ( currF , 3 * currVec , 1 , 3 ) = directional :: selected_vector_glyph_color (); directional :: glyph_lines_raw ( VMesh , FMesh , rawField , glyphColors , VField , FField , CField ); The selected face coloring is done as follows: CMesh = directional :: default_mesh_color (). replicate ( FMesh . rows (), 1 ); CMesh . row ( currF ) = directional :: selected_face_color (); ( Example 102 ) Editing several vectors on a single face. 103 Streamline Tracing \u00b6 Vector fields on surfaces are commonly visualized by tracing [streamlines] ( https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines ). Directional supports the seeding and tracing of streamlines, for all types of directionals. The seeds for the streamlines are initialized using streamlines_init , and the lines are traced using streamlines_next . Each call to streamlines_next extends each line by one triangle, allowing interactive rendering of the traced lines, as demonstrated in Example 103 . The streamline are compiled into meshes with the following: directional :: line_cylinders ( sl_state . start_point , sl_state . end_point , 0.0005 , color . replicate ( sl_state . start_point . rows (), 1 ), 4 , VFieldNew , FFieldNew , CFieldNew ); This creates meshes from many cylinders to have the appearance of continuous curves. ( Example 103 ) Interactive streamlines tracing. Chapter 2: Discretization and Representation \u00b6 In the following sections, we show some effects of working with different representations and converting between them. 201 Principal Matching \u00b6 One of the fundamental operations in directional-field processing is matching . That is, defining which vectors in face f_i f_i correspond to those in adjacent face f_j f_j . In Directional, we only work with order-preserving matchings: if vector k k in face f_i f_i is matched to vector m m in face f_j f_j , then for any l \\in \\mathbb{Z} l \\in \\mathbb{Z} , vector k+l k+l is matched to vector m+l m+l (modulu N N ) in the respective faces. Suppose that the orientation of the dual edge is f_i \\rightarrow f_j f_i \\rightarrow f_j , then the matching is encoded as m-k m-k . Some representations, like rotation angles, already encode the matching explicitly, but others do not. Therefore, it needs to be devised from the field. Given a raw field (in assumed CCW order in every face), it is possible to devise the rotation angles \\delta_{ij} \\delta_{ij} by the process of principal matching 6 . Principal matching is defined as the matching with minimal effort, always putting it within the range of [-\\pi, \\pi) [-\\pi, \\pi) (and therefore denoted as \u201cprincipal\u201d). It corresponds to the \u201csmallest angle\u201d matching for N N -RoSy fields. principal matching is done through the function principal_matching() (from in Example 201 ) as follow: directional :: principal_matching ( VMesh , FMesh , EV , EF , FE , rawField , matching , effort ); directional :: effort_to_indices ( VMesh , FMesh , EV , EF , effort , matching , N , singVertices , singIndices ); directional::effort_to_indices() computes the index of each vertex from the effort around it. The index of a vertex is the amount of rotations a directional object undergoes along a cycle around the vertex. A directional must return to itself after a cycle, and therefore the index is an integer I I when a vector m m in the face ended up in vector m+I m+I . Note that this can also include multiple full rotations (i.e., this is not taken modulu N N ), where the index is unbounded. The fractional part of the index is encoded by the matching; however, matching alone cannot encode integral indices (for instance, a single vector field has trivial (Zero) matching anywhere, but can have singularities). singVertices and singIndices only enumerate the singular vertices. ( Example 201 ) A Field is shown with singularities, and a single face is shown with the principal matching to its neighbors (in multiple colors). 202 Sampling \u00b6 This is an educational example that demonstrates the loss of information when moving between a polar (in this case, rotation angle) representation to a Cartesian representation, where the matching between vectors in adjacent faces is done with principal matching. In that case, low valence cycles and undersampling cause aliasing in the perceived field. There are three modes seen in the example: In the polar mode, the user can prescribe the index of a singularity directly. With this, the rotation angles between adjacent faces become arbitrarily large, and appear as noise in the low valence cycles. In the principal matching mode, the rotations are reconstructed from the field, without prior knowledge of the polar-prescribed rotations from the previous mode. The large rotation between adjacent faces is lost, which gives rise to a \u201csingularity party\u201d: many perceived singularities or a lower index. In the Cartesian mode, the field is interpolated on the free faces (white) from the constrained faces (red), keeping the red band fixed from the polar mode. We see a field that is smooth in the Cartesian sense, with more uniformly-placed singularities. ( Example 202 ) Alternating: the polar mode, the principal-matching mode, and the Cartesian mode. 203 Combing \u00b6 Given a matching (in this case, principal matching), it is possible to \u201ccomb\u201d the field. That is, re-index each face (keeping the CCW order), so that the vector indexing aligns perfectly with the matching to the neighbors\u2014then, the new matching on the dual edges becomes trivially zero. This operation is important in order to prepare a directional field for integration, for instance. In the presence of singularities, the field can only be combed up to a forest of paths that connect between singularities, also known as seams . Note that such paths do not necessarily cut the mesh into a simply-connected patch, but may only connects subgroups of singularities with indices adding up to an integer; as a trivial example, a 1-vector field is always trivially combed, even in the presence of integral singularities, and the set of seams is zero. The combing is done through the function directional::combing() as follows, taken from Example 203 directional :: combing ( VMesh , FMesh , EV , EF , FE , rawField , matching , combedField ); where combedField is the re-indexed rawField , done according to the input matching. We can recompute the matching on the combed field to retrieve the seams: directional :: principal_matching ( VMesh , FMesh , EV , EF , FE , combedField , combedMatching , combedEffort ); ( Example 203 ) Colored indices of directionals, alternating between combed (with seams) and uncombed) indexing. Chapter 3: Cartesian Methods \u00b6 Cartesian Fields \u00b6 The Cartesian representation is a meta-category for representation of vectors in explicit coordinates, either \\left(x,y\\right) \\left(x,y\\right) in some local 2D basis on a tangent plane, or \\left(x,y,z\\right) \\left(x,y,z\\right) in the ambient coordinates of the 3D space. The raw, representative (of an N N -RoSy), power field, and PolyVector representations are all such examples. Cartesian fields often do not automatically contain information about the matching, or rotation, of a field between one face and the next, and it needs to be computed using principal matching. This chapter focuses on computing fields with this representation. 301 Power Fields \u00b6 This representation is offered in 10 , but they did not give it a specific name (the method in general is called \u201cglobally optimal\u201d). We use the name \u201cpower fields\u201d given in 1 . A power field representation uses a complex basis in each tangent plane (face in our implementation), and represents an N N -RoSy using a power vector \u2014a single complex number y y per face so that its root set y=u^N y=u^N comprises the vectors of the N N -RoSy. By prescribing constraints y_B y_B on a set of faces B B , the algorithm interpolates the field to the rest of the faces y_I y_I by minimizing the face-based quadratic Dirichlet energy: y_I=\\text{argmin}\\sum_{e=(f,g)\\in F \\times F}{\\left|y_fe_f^N - y_ge_g^N\\right|^2}, y_I=\\text{argmin}\\sum_{e=(f,g)\\in F \\times F}{\\left|y_fe_f^N - y_ge_g^N\\right|^2}, where e_f e_f is the representation of the vector of edge e e in the basis of f f , and e_g e_g is for g g respectively. The field is computed through the function directional::power_field() . For a fixed set B B and varying y_B y_B , It is possible to speed up computations by precomputing the solver (sparse Cholsky for the positive-definite matrix) used to compute the power field. This is done by using the function directional::power_field_precompute() , coupled with the appropriate version of directional::power_field() . Note that field can be converted to representative and raw forms using the appropriate power_to_X functions. If the set B B is empty, then the computed field is the first Eigenvector of the Dirichlet energy. ( Example 301 ) Setting up a small subset of constraints (red faces), and interpolating (and normalizing in magnitude) the power field to the rest of the mesh. Note the singularities that are discovered through principal matching. 302 PolyVectors \u00b6 A Polyvector field 6 is a generalization of power fields that allows to represent independent vectors in each tangent plane. The representation is as the coefficient set a_{0 \\cdots N-1} a_{0 \\cdots N-1} of a monic complex polynomial in the local compex basis: P(z) = a_0 + a_1z + \\ldots + a_{N-1} z^{N-1} + z^N, P(z) = a_0 + a_1z + \\ldots + a_{N-1} z^{N-1} + z^N, where the roots P(z)=0 P(z)=0 are the vectors of the face-based directional object, represented as complex numbers in the local basis. The Dirichlet energy is as for power fields, except with a term for each a_i a_i , with the appropriate power i i . Note that an N N -RoSy is represented as a polynomial where all a a are zero except a_0 a_0 . Principal matching, combing, and effort are well-defined on PolyVectors as well. Example 302 allows a user to set individual vectors within each face, and see the interpolated result. The responsible function is directional::polyvector_field() . In this case as well, the solver can be prefactored in advance using directional::polyvector_precompute() . ( Example 302 ) Vectors are constrained individually in the constrained faces (red), and interpolated to the rest of the faces 303 PolyCurl Reduction \u00b6 Vector-field guided surface parameterization is based on the idea of designing the candidate gradients of the parameterization functions (which are tangent vector fields on the surface) instead of the functions themselves. Thus, vector-set fields ( N N -Rosy, frame fields, and polyvector fields) that are to be used for parameterization (and subsequent remeshing) should be as integrable as possible: it should be possible to locally comb them into individual vector fields that are approximately gradients of scalar functions. Fields obtained by \u201cas-smooth-as-possible\u201d design methods (eg. 11 , 10 , 6 , 2 , 15 ) do not have this property in general. In 7 , a method for creating integrable polyvector fields was introduced by the process of curl reduction . This method takes as input a given field and improves its integrability by iteratively reducing the PolyCurl of the field; that is, the coefficients of a dual-edge-based polynomial, whose roots are the curl of the matched vectors in the two adjacent faces. By working with PolyCurl instead of matching, the optimization can be done on the PolyVector itself, allowing for singularities to naturally emerge. However, the optimization is nonlinear\u2014it reduces the PolyCurl iteratively, while preserving the CCW order of the vectors (for a bijective parameterization), and opting for as smooth and orthogonal as possible result. A field that has zero PolyCurl everywhere is locally (away from singularities) integrable into N N different scalar functions; globally, it is integrable into a rotationally-seamless multi-branched function, which we further demonstrate in Chapter 5 . In Example 303 we demonstrate the PolyCurl-reduction optimization. ( Example 303 ) PolyCurl is iteratively reduced from an initial PolyVector field, Top: fields for iteration 0 (original), 10, and 50. Bottom: PolyCurl plots. The color is the norm of the vector of the roots of the PolyCurl. Its maximal value (infinity norm) appears below. 304 Conjugate Fields \u00b6 Two tangent vectors u u and v v are conjugate if $$k_1 (u^T d_1)(v^T d_1) + k_2(u^T d_2)(v^T d_2) = 0, $$ where k_1 k_1 and k_2 k_2 are the principal curvatures and d_1 d_1 and d_2 d_2 are the respective principal directions. Conjugate vector fields are very important in architectural geometry: their integral lines form, informally speaking, an infinitesimal planar quad mesh. As such, the finite quad mesh that results from discretizing conjugate networks is a good candidate for consequent planarity parameterization 12 . Finding a conjugate vector field that satisfies given directional constraints is a standard problem in architectural geometry, which can be tackled by deforming a 2^2 2^2 PolyVector field to the closest conjugate field. Such an algorithm was presented in 6 , which alternates between a global smoothness and orthogonality step, and a local step that projects the field on every face to the closest conjugate field ( Example 304 ). ( Example 304 ) A smooth 2^2 2^2 -PolyVector field (left) is deformed to become a conjugate field (right). Top: fields Bottom: conjugacy plots. Chapter 4: Polar Methods \u00b6 Polar Fields \u00b6 Polar fields are represented using angles. These angles may encode the rotation from some given basis on a tangent plane (and so it is a \u201clogarithmic\u201d representation, when compared to Cartesian methods), or an angle difference between two neighboring tangent planes (in the sense of deviation from parallel transport). The former usually requires integer variables for directional field design. The latter does not, but state-of-the-art methods require the prescription of indices around independent dual cycles in the mesh. Currently, Directional supports the latter. 401 Index Prescription \u00b6 The notion of encoding rotation angles on dual edges, as means to encode deviation from parallel transport between adjacent tangent planes, appeared in several formats in the literature 5 , 11 . The formulation and notation we use in Directional is that of Trivial Connections 5 . Trivial connection solves for a single rotation angle \\delta_{ij} \\delta_{ij} per (dual) edge e_{ij} e_{ij} between two faces f_i f_i and f_j f_j , encoding the deviation from parallel transport between them. The algorithm first computes a spanning set of basis cycles , around all of which the sum of \\delta_{ij} \\delta_{ij} has to be prescribed. The summation is defined as a matrix H H . Every such cycle (row in the matrix) has an original curvature K_0 K_0 , defined as a discrete angle defect, and the prescribed index defines an alternative curvature. The algorithm solves for the smoothest field, in the 2-norm least squares sense, as follows: \\delta = \\text{argmin}\\ |\\delta_{ij}|^2\\ s.t.\\ H\\delta = -K_0 + K. \\delta = \\text{argmin}\\ |\\delta_{ij}|^2\\ s.t.\\ H\\delta = -K_0 + K. H H is the matrix that defines the basis-cycles sum, K_0 K_0 is a vector of the original curvatures of every basis cycle, and K K is the prescribed curvatures, which result from prescribed singularity indices: for regular cycles, we prescribe K=0 K=0 , and for a singular cycle with prescribed singularity index \\frac{i}{N} \\frac{i}{N} , we set K=\\frac{2\\pi i}{N} K=\\frac{2\\pi i}{N} . the sum of K K has to conform to the Poincar\u00e9 index theorem. However, generator (handle) cycles can admit unbounded indices. See 5 for exact details. If the input obeys the sum, the result obeys the prescribed indices around the cycles everywhere. The representation is differential , where the single global degree of freedom is resolved by setting a single direction in a single arbitrary face. Note that the correct definition for \u201ccycle curvature\u201d corresponds to the so-called \u201ccycle holonomy\u201d, only up to integer multiples of 2\\pi 2\\pi . However, in the discrete setting, the curvature should theoretically be computed as the exact discrete angle defect, in which for inner vertices we use 2\\pi-\\sum{\\alpha} 2\\pi-\\sum{\\alpha} , and for boundary vertices we use \\pi - \\sum{\\alpha} \\pi - \\sum{\\alpha} ( \\alpha \\alpha are the angles at the corners of a vertex). For a cycle aggregating many vertices, such as a boundary-loop cycle, we add up all the defects. That is required for exact discrete Poincar\u00e9 index consistency. Note that the boundary indices define how many rotations of the vector field the boundary loop \u201csees\u201d. As an example, a constant field on a simple disc in the plane has indices 0 0 for all inner vertices, but the boundary index is in fact 1 1 \u2014This obeys the total index sum \\chi = 2-2g-b = 2-0-1=1 \\chi = 2-2g-b = 2-0-1=1 ( g g stands for genus and b b for number of boundary loops) Basis Cycles \u00b6 The basis cycles form the cycles around which curvatures (and singularities) have to be prescribed on the mesh. The sum on basis cycles is described in a sparse matrix H H of size |cycles|\\times |E_I| |cycles|\\times |E_I| , where E_I E_I is the number of inner edges in the mesh. Each row in the matrix describes the sum over one cycle, and contains 1 1 or -1 -1 values depending on the (arbitrary) orientation of the dual edge participating in the cycle to the respective face. There are three types of cycles, so ordered in the rows of H H : 1 1 -ring dual cycles around each inner vertex, on which vertex-based singularities can be encoded (the relevant part of H H is basically \\left(d_0\\right)^T \\left(d_0\\right)^T in discrete exterior calculus, restricted to inner edges). Cycles around mesh boundary loops. Cycles around the 2g 2g topological generators (independent handles). The method directional::dual_cycles() computes the proper basis cycles and matrix H H . To be able to intuitively prescribe singularities to inner vertices, the method also returns a conversion vector vertex2cycle , and the list of indices of inner edges from the list of edges. The singularity indices that are prescribed contain the singularity index corresponding to each basis cycle. A value of k \\in \\mathbb{Z} k \\in \\mathbb{Z} represents an \\frac{2\\pi k}{N} \\frac{2\\pi k}{N} rotation around the respective cycle. If the prescribed indices do not conform to the Poincar\u00e9 index theorem, a result will still be computed by least squares, but it will be unpredictable. The algorithm is performed through the function directional::index_prescription() , which can also accept a solver for precomputation, for the purpose of prefactoring H H only once. ( Example 401 ) Indices are prescribed on several vertex singularities, and on a generator loop, to match the index theorem. Chapter 5: Seamless Parameterization \u00b6 Directional fields are commonly used to create seamless parameterizations 2 , 9 , 13 . Recall that combing trivializes the matching everywhere except a sparse set of seams. We augment these seams so that the mesh is cut into a topological disc. Then, we treat a combed N N -directional \\left\\{u_0,\\cdots,u_{N-1}\\right\\} \\left\\{u_0,\\cdots,u_{N-1}\\right\\} as a set of N N candidate gradients for N N vertex-based scalar functions \\left\\{F_0,\\cdots,F_{N-1}\\right\\} \\left\\{F_0,\\cdots,F_{N-1}\\right\\} on the cut mesh. We then solve the Poisson problem: $$ F = argmin{\\sum_{i=0}^{N-1}{\\left|\\nabla F_i - u_i\\right|^2}} $$. Consider a seam edge e_{ij} e_{ij} between original vertices v_i v_i and v_j v_j , and between adjacent faces f_k f_k and f_l f_l . The two vertices are then cut into four corners v_{i,k},v_{j,k},v_{i,l},v_{j,l} v_{i,k},v_{j,k},v_{i,l},v_{j,l} . Note that some corners might be identical, if the seam edge is at a singularity. Across the seam edge, we enforce the (linear) seamless conditions: F_{i,k}= \\pi_e \\cdot F_{i,l} + T_e, F_{i,k}= \\pi_e \\cdot F_{i,l} + T_e, where \\pi_e:N \\times N \\pi_e:N \\times N is a permutation matrix attached to the (dual) edge e e , matching values in the integrated function F F as it did for the directional field v v . and T_e:N \\times 1 T_e:N \\times 1 is a translational jump (also: period jump), that encodes the discontinuity in F F across the seam. For quick intuition, this encodes the integration of the function over a loop around the mesh beginning and ending with the seam edge: in a quad-mesh parameterization, it is the number of quads in such a loop. Seamless parameterizations are denoted as such for that obeying the seamless constraints; it can be easily shown 9 that the translational jumps T_e T_e is in fact uniform across seam curves between singularities. Thus, the number of such translational jump variables is the number of seam curves in the mesh ( \\times N \\times N ) 501 Seamless Parameterization \u00b6 In Example 501 we demonstrate the computation of such a parameterization. The core functionality is in these lines: directional :: ParameterizationData pd ; directional :: cut_mesh_with_singularities ( VMeshWhole , FMeshWhole , singVertices , pd . face2cut ); ... directional :: setup_parameterization ( N , VMeshWhole , FMeshWhole , EV , EF , FE , combedMatching , singVertices , pd , VMeshCut , FMeshCut ); double lengthRatio = 0.01 ; bool isInteger = false ; //do not do translational seamless. std :: cout << \"Solving parameterization\" << std :: endl ; directional :: parameterize ( VMeshWhole , FMeshWhole , FE , combedField , lengthRatio , pd , VMeshCut , FMeshCut , isInteger , cutUV ); directional::cut_mesh_with_singularities() encodes the the seams in pd.face2cut . directional::setup_parameterization() creates the Poisson system and the constraints, and creates the actual cut mesh in VMeshCut and FMeshCut . directional::parameterize() solves the parameterization, and puts the result in cutUV . The functionality is currently limited only to 2^2 2^2 fields ( N=4 N=4 ) with symmetry assumed. lengthRatio encodes a global scale for the Poisson problem (scaling the fields uniformly), where the ratio is measured against the bounding box diagonal. The variable isInteger refers set to false which means that the parameterization would only be rotationally-seamless ; the appearance across the seams would align only in direction. The next example considers the stronger option. ( Example 501 ) Left: directional field. Right: rotationally-seamless parameterization. Note that the direction of the texture aligns across seams. 502 Mixed-Integer Parametrization \u00b6 To use seamless parameterizations for the purpose of quad meshing, we require the texture to be fully-seamless across seams. With this, the seams are virtually invisible on the cut mesh. This can be done by setting all T_e T_e to values in 2\\mathbb{Z} 2\\mathbb{Z} (for why double integers are necessary, see 9 ). The solving is done by simple iterative rounding 2 : we choose the value in T_e T_e which is the closest to a double integer, round and fix it, and repeat until all T_e T_e are rounded. Note that CoMISo 3 has a more sophisticated Gauss-Seidel rounding algorithm that is more efficient; however, we include an implementation of our simpler version in Directional to avoid the dependency, and since our version will be used for general N N -function parameterization in future versions of Directional. Mixed-integer parameterization is demonstrated in Example 502 . The essential difference from Example 501 is by simply setting isInteger=true , when passed to directional::parameterize() . Note: The input field horsers-cf.rawfield is computed according to Example 303 to have negligible PolyCurl. As such, the rotationally-seamless parameterization has a very low error ( L_\\infty L_\\infty of 1.25778\\cdot 10^{-5} 1.25778\\cdot 10^{-5} ). The rounding iterations incur some error, but it is rather low as well (after rounding 116 116 variables it climbs to L_\\infty=0.657496 L_\\infty=0.657496 ); we therefore recommend to warm-start a mixed-integer parameterization with a curl-reduced directional field. ( Example 502 ) Left to right: directional field, rotationally-seamless parameterization (before rounding), fully-seamless parameterization. Outlook for continuing development \u00b6 Directional is a budding project, and there are many algorithms in the state-of-the-art that we look forward to implement, with the help of volunteer researchers and practitioners from the field. Prominent examples of desired implementations are: Support for 3D fields, particularly Octahedral fields 14 , both in tet meshes and with the boundary-element method. A discrete exterior calculus framework. Differential operators and Hodge decomposition. Support for tensor fields. Face-based polar representation, and mixed-integer directional algorithms. Vertex-based representations. Advanced and better visualization techniques. References \u00b6 Omri Azencot, Etienne Corman, Mirela Ben-Chen, Maks Ovsjanikov, Consistent Functional Cross Field Design for Mesh Quadrangulation , 2017. \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt, Mixed-integer quadrangulation , 2009. \u21a9 \u21a9 \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt, Practical Mixed-Integer Optimization for Geometry Processing , 2012. \u21a9 Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly, Shape-Up: Shaping Discrete Geometry with Projections , 2012. \u21a9 Keenan Crane, Mathieu Desbrun, Peter Schr\u00f6der, Trivial Connections on Discrete Surfaces , 2010. \u21a9 \u21a9 \u21a9 \u21a9 Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Designing N-PolyVector Fields with Complex Polynomials , 2014. \u21a9 \u21a9 \u21a9 \u21a9 Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Integrable PolyVector Fields , 2015. \u21a9 Fernando de Goes, Mathieu Desbrun, Yiying Tong, Vector Field Processing on Triangle Meshes , 2016. \u21a9 Felix K\u00e4lberer, Matthias Nieser, Konrad Polthier, QuadCover - Surface Parameterization using Branched Coverings , 2007 \u21a9 \u21a9 \u21a9 Felix Kn\u00f6ppel, Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der, Globally Optimal Direction Fields , 2013. \u21a9 \u21a9 Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno L\u00e9vy, N-Symmetry Direction Field Design , 2008. \u21a9 \u21a9 \u21a9 Yang Liu, Weiwei Xu, Jun Wang, Lifeng Zhu, Baining Guo, Falai Chen, Guoping Wang, General Planar Quadrilateral Mesh Design Using Conjugate Direction Field , 2008. \u21a9 Ashish Myles, Nico Pietroni, Denis Zorin, Robust Field-aligned Global Parametrization , 2014. \u21a9 Justin Solomon, Amir Vaxman, David Bommes, Boundary Element Octahedral Fields in Volumes , 2017. \u21a9 Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung, Frame Fields: Anisotropic and Non-Orthogonal Cross Fields , 2014. \u21a9 Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen, Directional Field Synthesis, Design, and Processing , 2016. \u21a9 \u21a9","title":"Tutorial"},{"location":"tutorial/#introduction","text":"Directional is a C++ geometry processing library written as an extension library to libigl , with a specialization in directional-field processing. The functionality is based on the definitions and taxonomy surveyed theoretically in 16 , and through it by the relevant papers in the literature. It contains tools to edit, analyze, and visualize directional fields of various degrees and symmetries. The underlying structure extends the general philosophy of libigl : the library is header only, where each header contains a set of functions closely related (for instance, the precomputation and computation of some directional quantity over a mesh). For the most part, one header contains only one function. The data structures are, for the most part, simple matrices in Eigen , and the library avoids complicated and nested structures, relying instead on standalone functions. The visualization is done on the basis of libigl viewer, with some extended options that allow the rendering of directional fields. The header files contain documentation of the parameters to each function and their required composition; in this tutorial we will mostly tie the functionality of Directional to the theoretical concepts of directional fields and the methods to process them.","title":"Introduction"},{"location":"tutorial/#installing-the-tutorial-examples","text":"This tutorial comprises an exhaustive set of examples that demonstrates the capabilities of Directional, where every subchapter entails a single concept. The tutorial code can be installed by going into the tutorial folder from the main Directional folder, and typing the following instructions in a terminal: mkdir build cd build cmake - DCMAKE_BUILD_TYPE = Release .. / make This will build all tutorial chapters in the build folder. The necessary dependencies will be appended and built automatically. To build in windows, use the cmake-gui .. options instead of the last two commands, and create the project using Visual Studio, with the proper tutorial subchapter as the \u201cstartup project\u201d. To access a single example, say 202_Sampling , go to the build subfolder, and the executable will be there. Command-line arguments are never required; the data is read from the shared folder directly for each example. Most examples require a modest amount of user interaction; the instructions of what to do are given in the command-line output upon execution.","title":"Installing the tutorial examples"},{"location":"tutorial/#discretization","text":"There are several ways to represent tangent planes on triangle meshes, although not all of them compatible with the different information that the fields convey. Mainstream discretizations roughly categorize into face-based, edge-based, and vertex-basex discretizations (see 8 for an in-depth analysis). The only discretization currently supported by Directional is that of tangent face-based fields, where the discrete tangent plane is taken to be the supporting plane to each (naturally flat) face. We also use a local basis (provided by igl::local_basis() ) to parameterize each tangent plane. Notions like connection, parallel transport, and consequently smoothness, are measured on dual edges between adjacent faces.","title":"Discretization"},{"location":"tutorial/#representation","text":"The representation of a directional field is the way it is encoded in each discrete tangent plane, and across adjacent tangent planes. Directional uses several different representations to describe directional fields. We denote the number of faces in the mesh as |F| |F| , the set of inner edges (adjacent to two triangles) as E_I E_I , and the degree of the field as N N (must be fixed for the entire field). The supported representations are as follows, where the taxonomy is based on that of the directional field course 16 : Raw - A |F|\\times 3N |F|\\times 3N double matrix, representing an 1^N 1^N -vector field (a directional with N N independent vectors in each face) in the form X_1, Y_1, Z_1, X_2, Y_2, Z_2, \\cdots X_N, Y_N, Z_N X_1, Y_1, Z_1, X_2, Y_2, Z_2, \\cdots X_N, Y_N, Z_N per face. Vectors are assumed to be ordered in counterclockwise order in most Directional functions that process raw fields. Representative . A |F| \\times 3 |F| \\times 3 double matrix that represents a rotationally symmetric N N -vector field, known as an N N -RoSy. The single vector is an arbitrary \u201cfirst\u201d vector in the face, and the rest of the vectors are deduced by rotations of \\frac{2\\cdot\\pi}{N} \\frac{2\\cdot\\pi}{N} . That means the all functions should also accept N N as input to decode the full field. Rotation Angles . A |E_I| |E_I| -sized double vector representing the rotation angle between two directions (without magnitude information) on two adjacent triangles. The rotation represents the deviation from the Levi-Civita parallel transport 5 , 11 . This representation may only encode N N -direction fields (no magnitude). Note that the effort (sum of all rotations) is then N N times rotation angles. Since this is a differential quantity, an extra global rotation needs to be given to uniquely decode the full face-based field. Power Field - An |F| |F| -sized complex vector, encoding an N N -RoSy object as a single complex number y=u^N y=u^N encoded in the local basis, where the N N -RoSy is the set of roots u \\cdot e^{\\frac{2\\pi i k}{N}}, k \\in [0,N-1] u \\cdot e^{\\frac{2\\pi i k}{N}}, k \\in [0,N-1] . The magnitude is also encoded this way, though it may be neglected in some applications. The representation depends on a local 2D 2D basis, such as one that could be obtained from igl::local_basis() . PolyVector - A |F| \\times N |F| \\times N complex matrix, representing the coefficients a a of a monic complex polynomial f(z)=z^N+\\sum_{i=0}^{N-1}{a_iz^i} f(z)=z^N+\\sum_{i=0}^{N-1}{a_iz^i} , which roots u u are the encoded 1^N 1^N -vector field. Every row is encoded as a_{0},\\cdots, a_{N-1} a_{0},\\cdots, a_{N-1} , where a_0 a_0 is the free coefficient. In case where the field is an N N -RoSy, all coefficients but a_0 a_0 are zero. Directional provides a number of conversion functions to switch between different representations. Each of the functions is of the form rep1_to_rep2 , where rep1 and rep2 are the representation names in the above list. e.g., rotation_to_representative() and polyvector_to_raw() . Some possible combinations are given by composing two functions in sequence. However, note that not every conversion is possible; for instance, it is not possible to convert between PolyVectors and rotation angles, as they do not possess the same power of expression (with current state-of-the-art\u2026). For N N -RoSy fields, for instance, you will most likely work primarily with the power field, representative, or rotation-angle representation. converting into the more explicit raw representation is often needed for I/O and visualization.","title":"Representation"},{"location":"tutorial/#chapter-1-io-and-visualization","text":"","title":"Chapter 1: I/O and Visualization"},{"location":"tutorial/#visualization-paradigm","text":"Directional uses the libigl viewer (although a viewer is not necessary for the core functionality), and augments it with auxiliary functionality and color schemes that pertain to directional fields specifically. The drawing paradigm in Directional is that the visualization functions create actual meshes (vertices, faces, and per-face colors) for the different components of the field: box-like meshes for per-face glyphs representing vectors, sphere meshes for representing singularities, piecewise-cylinder curves to represent streamlines, and more. These visualization meshes can then be stored in libigl viewer as multiple meshes and visualized as needed. The color schemes and directional visualization mesh creation functionality are mostly given in visualization_schemes.h , and can be called to create a homogeneous look for visualizing fields in applications. Most notable are indexed_glyph_colors() that gives back glyph meshes colored by index per face, and default_singularity_colors() that produces singularity meshes according to index. Other visualization functionality is detailed below in the context of the different examples.","title":"Visualization paradigm"},{"location":"tutorial/#101-glyph-rendering","text":"The most basic operation on directional fields is reading them from a file and drawing them in the most explicit way. In Example 101 , a field is read from a file as follows: directional :: read_raw_field ( TUTORIAL_SHARED_PATH \"/bumpy.rawfield\" , N , rawField ); directional :: read_singularities ( TUTORIAL_SHARED_PATH \"/bumpy.sings\" , N , singVertices , singIndices ); The field is read in raw format (see File Formats ), which is detailed in the Introduction . The field is face-based , and the singularities are consequently vertex-based , where singVertices are the singular vertices, and singIndices are the corresponding integer indices, so that the actual fractional indices are \\frac{singIndices}{N} \\frac{singIndices}{N} . The visualization meshes for the glyphs and the singularities are obtained as follows directional :: glyph_lines_raw ( VMesh , FMesh , rawField , directional :: default_glyph_color (), VField , FField , CField ); directional :: singularity_spheres ( VMesh , FMesh , N , singVertices , singIndices , VSings , FSings , CSings ); These two operations do not produce any active drawing; they create meshes that extend the original geometry, and then get passed to libigl viewer. directional::glyph_lines_raw() creates box-like meshes on the faces that constitute the glyph drawing : simply drawing the vectors upon the faces in their \\left(x,y,z\\right) \\left(x,y,z\\right) coordinates, starting from the face barycenter. There are several possibilities to color these vectors, which can be local or global; check the documentation to the function in the header. In this case, we give the default_glyph_color() from the Directional visualization schemes. Vectors are drawn in their given magnitudes, up to a global scale. By default, this scale is set to be related to the average edge length\u2014it can be manually set by all visualization-mesh-creating function. directional::singularity_spheres() creates a mesh of small spheres on vertices, where the size of the sphere is devised by default. The spheres are only created where the index is different than 0 0 . Example 101 Glyph Rendering on a mesh, with singularities visible.","title":"101 Glyph Rendering"},{"location":"tutorial/#102-picking-and-editing","text":"This example demonstrates the editing paradigm in Directional, based on libigl picking. A face and a vector within the face are chosen, and clicking on a new direction for the vector changes it. Note the different setting of colors for glyphs: for the selected face and for the selected vector in the face particularly, via the following code in Example 102 . Eigen :: MatrixXd glyphColors = directional :: default_glyph_color (). replicate ( FMesh . rows (), N ); glyphColors . row ( currF ) = directional :: selected_face_glyph_color (). replicate ( 1 , N ); glyphColors . block ( currF , 3 * currVec , 1 , 3 ) = directional :: selected_vector_glyph_color (); directional :: glyph_lines_raw ( VMesh , FMesh , rawField , glyphColors , VField , FField , CField ); The selected face coloring is done as follows: CMesh = directional :: default_mesh_color (). replicate ( FMesh . rows (), 1 ); CMesh . row ( currF ) = directional :: selected_face_color (); ( Example 102 ) Editing several vectors on a single face.","title":"102 Picking and editing"},{"location":"tutorial/#103-streamline-tracing","text":"Vector fields on surfaces are commonly visualized by tracing [streamlines] ( https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines ). Directional supports the seeding and tracing of streamlines, for all types of directionals. The seeds for the streamlines are initialized using streamlines_init , and the lines are traced using streamlines_next . Each call to streamlines_next extends each line by one triangle, allowing interactive rendering of the traced lines, as demonstrated in Example 103 . The streamline are compiled into meshes with the following: directional :: line_cylinders ( sl_state . start_point , sl_state . end_point , 0.0005 , color . replicate ( sl_state . start_point . rows (), 1 ), 4 , VFieldNew , FFieldNew , CFieldNew ); This creates meshes from many cylinders to have the appearance of continuous curves. ( Example 103 ) Interactive streamlines tracing.","title":"103 Streamline Tracing"},{"location":"tutorial/#chapter-2-discretization-and-representation","text":"In the following sections, we show some effects of working with different representations and converting between them.","title":"Chapter 2: Discretization and Representation"},{"location":"tutorial/#201-principal-matching","text":"One of the fundamental operations in directional-field processing is matching . That is, defining which vectors in face f_i f_i correspond to those in adjacent face f_j f_j . In Directional, we only work with order-preserving matchings: if vector k k in face f_i f_i is matched to vector m m in face f_j f_j , then for any l \\in \\mathbb{Z} l \\in \\mathbb{Z} , vector k+l k+l is matched to vector m+l m+l (modulu N N ) in the respective faces. Suppose that the orientation of the dual edge is f_i \\rightarrow f_j f_i \\rightarrow f_j , then the matching is encoded as m-k m-k . Some representations, like rotation angles, already encode the matching explicitly, but others do not. Therefore, it needs to be devised from the field. Given a raw field (in assumed CCW order in every face), it is possible to devise the rotation angles \\delta_{ij} \\delta_{ij} by the process of principal matching 6 . Principal matching is defined as the matching with minimal effort, always putting it within the range of [-\\pi, \\pi) [-\\pi, \\pi) (and therefore denoted as \u201cprincipal\u201d). It corresponds to the \u201csmallest angle\u201d matching for N N -RoSy fields. principal matching is done through the function principal_matching() (from in Example 201 ) as follow: directional :: principal_matching ( VMesh , FMesh , EV , EF , FE , rawField , matching , effort ); directional :: effort_to_indices ( VMesh , FMesh , EV , EF , effort , matching , N , singVertices , singIndices ); directional::effort_to_indices() computes the index of each vertex from the effort around it. The index of a vertex is the amount of rotations a directional object undergoes along a cycle around the vertex. A directional must return to itself after a cycle, and therefore the index is an integer I I when a vector m m in the face ended up in vector m+I m+I . Note that this can also include multiple full rotations (i.e., this is not taken modulu N N ), where the index is unbounded. The fractional part of the index is encoded by the matching; however, matching alone cannot encode integral indices (for instance, a single vector field has trivial (Zero) matching anywhere, but can have singularities). singVertices and singIndices only enumerate the singular vertices. ( Example 201 ) A Field is shown with singularities, and a single face is shown with the principal matching to its neighbors (in multiple colors).","title":"201 Principal Matching"},{"location":"tutorial/#202-sampling","text":"This is an educational example that demonstrates the loss of information when moving between a polar (in this case, rotation angle) representation to a Cartesian representation, where the matching between vectors in adjacent faces is done with principal matching. In that case, low valence cycles and undersampling cause aliasing in the perceived field. There are three modes seen in the example: In the polar mode, the user can prescribe the index of a singularity directly. With this, the rotation angles between adjacent faces become arbitrarily large, and appear as noise in the low valence cycles. In the principal matching mode, the rotations are reconstructed from the field, without prior knowledge of the polar-prescribed rotations from the previous mode. The large rotation between adjacent faces is lost, which gives rise to a \u201csingularity party\u201d: many perceived singularities or a lower index. In the Cartesian mode, the field is interpolated on the free faces (white) from the constrained faces (red), keeping the red band fixed from the polar mode. We see a field that is smooth in the Cartesian sense, with more uniformly-placed singularities. ( Example 202 ) Alternating: the polar mode, the principal-matching mode, and the Cartesian mode.","title":"202 Sampling"},{"location":"tutorial/#203-combing","text":"Given a matching (in this case, principal matching), it is possible to \u201ccomb\u201d the field. That is, re-index each face (keeping the CCW order), so that the vector indexing aligns perfectly with the matching to the neighbors\u2014then, the new matching on the dual edges becomes trivially zero. This operation is important in order to prepare a directional field for integration, for instance. In the presence of singularities, the field can only be combed up to a forest of paths that connect between singularities, also known as seams . Note that such paths do not necessarily cut the mesh into a simply-connected patch, but may only connects subgroups of singularities with indices adding up to an integer; as a trivial example, a 1-vector field is always trivially combed, even in the presence of integral singularities, and the set of seams is zero. The combing is done through the function directional::combing() as follows, taken from Example 203 directional :: combing ( VMesh , FMesh , EV , EF , FE , rawField , matching , combedField ); where combedField is the re-indexed rawField , done according to the input matching. We can recompute the matching on the combed field to retrieve the seams: directional :: principal_matching ( VMesh , FMesh , EV , EF , FE , combedField , combedMatching , combedEffort ); ( Example 203 ) Colored indices of directionals, alternating between combed (with seams) and uncombed) indexing.","title":"203 Combing"},{"location":"tutorial/#chapter-3-cartesian-methods","text":"","title":"Chapter 3: Cartesian Methods"},{"location":"tutorial/#cartesian-fields","text":"The Cartesian representation is a meta-category for representation of vectors in explicit coordinates, either \\left(x,y\\right) \\left(x,y\\right) in some local 2D basis on a tangent plane, or \\left(x,y,z\\right) \\left(x,y,z\\right) in the ambient coordinates of the 3D space. The raw, representative (of an N N -RoSy), power field, and PolyVector representations are all such examples. Cartesian fields often do not automatically contain information about the matching, or rotation, of a field between one face and the next, and it needs to be computed using principal matching. This chapter focuses on computing fields with this representation.","title":"Cartesian Fields"},{"location":"tutorial/#301-power-fields","text":"This representation is offered in 10 , but they did not give it a specific name (the method in general is called \u201cglobally optimal\u201d). We use the name \u201cpower fields\u201d given in 1 . A power field representation uses a complex basis in each tangent plane (face in our implementation), and represents an N N -RoSy using a power vector \u2014a single complex number y y per face so that its root set y=u^N y=u^N comprises the vectors of the N N -RoSy. By prescribing constraints y_B y_B on a set of faces B B , the algorithm interpolates the field to the rest of the faces y_I y_I by minimizing the face-based quadratic Dirichlet energy: y_I=\\text{argmin}\\sum_{e=(f,g)\\in F \\times F}{\\left|y_fe_f^N - y_ge_g^N\\right|^2}, y_I=\\text{argmin}\\sum_{e=(f,g)\\in F \\times F}{\\left|y_fe_f^N - y_ge_g^N\\right|^2}, where e_f e_f is the representation of the vector of edge e e in the basis of f f , and e_g e_g is for g g respectively. The field is computed through the function directional::power_field() . For a fixed set B B and varying y_B y_B , It is possible to speed up computations by precomputing the solver (sparse Cholsky for the positive-definite matrix) used to compute the power field. This is done by using the function directional::power_field_precompute() , coupled with the appropriate version of directional::power_field() . Note that field can be converted to representative and raw forms using the appropriate power_to_X functions. If the set B B is empty, then the computed field is the first Eigenvector of the Dirichlet energy. ( Example 301 ) Setting up a small subset of constraints (red faces), and interpolating (and normalizing in magnitude) the power field to the rest of the mesh. Note the singularities that are discovered through principal matching.","title":"301 Power Fields"},{"location":"tutorial/#302-polyvectors","text":"A Polyvector field 6 is a generalization of power fields that allows to represent independent vectors in each tangent plane. The representation is as the coefficient set a_{0 \\cdots N-1} a_{0 \\cdots N-1} of a monic complex polynomial in the local compex basis: P(z) = a_0 + a_1z + \\ldots + a_{N-1} z^{N-1} + z^N, P(z) = a_0 + a_1z + \\ldots + a_{N-1} z^{N-1} + z^N, where the roots P(z)=0 P(z)=0 are the vectors of the face-based directional object, represented as complex numbers in the local basis. The Dirichlet energy is as for power fields, except with a term for each a_i a_i , with the appropriate power i i . Note that an N N -RoSy is represented as a polynomial where all a a are zero except a_0 a_0 . Principal matching, combing, and effort are well-defined on PolyVectors as well. Example 302 allows a user to set individual vectors within each face, and see the interpolated result. The responsible function is directional::polyvector_field() . In this case as well, the solver can be prefactored in advance using directional::polyvector_precompute() . ( Example 302 ) Vectors are constrained individually in the constrained faces (red), and interpolated to the rest of the faces","title":"302 PolyVectors"},{"location":"tutorial/#303-polycurl-reduction","text":"Vector-field guided surface parameterization is based on the idea of designing the candidate gradients of the parameterization functions (which are tangent vector fields on the surface) instead of the functions themselves. Thus, vector-set fields ( N N -Rosy, frame fields, and polyvector fields) that are to be used for parameterization (and subsequent remeshing) should be as integrable as possible: it should be possible to locally comb them into individual vector fields that are approximately gradients of scalar functions. Fields obtained by \u201cas-smooth-as-possible\u201d design methods (eg. 11 , 10 , 6 , 2 , 15 ) do not have this property in general. In 7 , a method for creating integrable polyvector fields was introduced by the process of curl reduction . This method takes as input a given field and improves its integrability by iteratively reducing the PolyCurl of the field; that is, the coefficients of a dual-edge-based polynomial, whose roots are the curl of the matched vectors in the two adjacent faces. By working with PolyCurl instead of matching, the optimization can be done on the PolyVector itself, allowing for singularities to naturally emerge. However, the optimization is nonlinear\u2014it reduces the PolyCurl iteratively, while preserving the CCW order of the vectors (for a bijective parameterization), and opting for as smooth and orthogonal as possible result. A field that has zero PolyCurl everywhere is locally (away from singularities) integrable into N N different scalar functions; globally, it is integrable into a rotationally-seamless multi-branched function, which we further demonstrate in Chapter 5 . In Example 303 we demonstrate the PolyCurl-reduction optimization. ( Example 303 ) PolyCurl is iteratively reduced from an initial PolyVector field, Top: fields for iteration 0 (original), 10, and 50. Bottom: PolyCurl plots. The color is the norm of the vector of the roots of the PolyCurl. Its maximal value (infinity norm) appears below.","title":"303 PolyCurl Reduction"},{"location":"tutorial/#304-conjugate-fields","text":"Two tangent vectors u u and v v are conjugate if $$k_1 (u^T d_1)(v^T d_1) + k_2(u^T d_2)(v^T d_2) = 0, $$ where k_1 k_1 and k_2 k_2 are the principal curvatures and d_1 d_1 and d_2 d_2 are the respective principal directions. Conjugate vector fields are very important in architectural geometry: their integral lines form, informally speaking, an infinitesimal planar quad mesh. As such, the finite quad mesh that results from discretizing conjugate networks is a good candidate for consequent planarity parameterization 12 . Finding a conjugate vector field that satisfies given directional constraints is a standard problem in architectural geometry, which can be tackled by deforming a 2^2 2^2 PolyVector field to the closest conjugate field. Such an algorithm was presented in 6 , which alternates between a global smoothness and orthogonality step, and a local step that projects the field on every face to the closest conjugate field ( Example 304 ). ( Example 304 ) A smooth 2^2 2^2 -PolyVector field (left) is deformed to become a conjugate field (right). Top: fields Bottom: conjugacy plots.","title":"304 Conjugate Fields"},{"location":"tutorial/#chapter-4-polar-methods","text":"","title":"Chapter 4: Polar Methods"},{"location":"tutorial/#polar-fields","text":"Polar fields are represented using angles. These angles may encode the rotation from some given basis on a tangent plane (and so it is a \u201clogarithmic\u201d representation, when compared to Cartesian methods), or an angle difference between two neighboring tangent planes (in the sense of deviation from parallel transport). The former usually requires integer variables for directional field design. The latter does not, but state-of-the-art methods require the prescription of indices around independent dual cycles in the mesh. Currently, Directional supports the latter.","title":"Polar Fields"},{"location":"tutorial/#401-index-prescription","text":"The notion of encoding rotation angles on dual edges, as means to encode deviation from parallel transport between adjacent tangent planes, appeared in several formats in the literature 5 , 11 . The formulation and notation we use in Directional is that of Trivial Connections 5 . Trivial connection solves for a single rotation angle \\delta_{ij} \\delta_{ij} per (dual) edge e_{ij} e_{ij} between two faces f_i f_i and f_j f_j , encoding the deviation from parallel transport between them. The algorithm first computes a spanning set of basis cycles , around all of which the sum of \\delta_{ij} \\delta_{ij} has to be prescribed. The summation is defined as a matrix H H . Every such cycle (row in the matrix) has an original curvature K_0 K_0 , defined as a discrete angle defect, and the prescribed index defines an alternative curvature. The algorithm solves for the smoothest field, in the 2-norm least squares sense, as follows: \\delta = \\text{argmin}\\ |\\delta_{ij}|^2\\ s.t.\\ H\\delta = -K_0 + K. \\delta = \\text{argmin}\\ |\\delta_{ij}|^2\\ s.t.\\ H\\delta = -K_0 + K. H H is the matrix that defines the basis-cycles sum, K_0 K_0 is a vector of the original curvatures of every basis cycle, and K K is the prescribed curvatures, which result from prescribed singularity indices: for regular cycles, we prescribe K=0 K=0 , and for a singular cycle with prescribed singularity index \\frac{i}{N} \\frac{i}{N} , we set K=\\frac{2\\pi i}{N} K=\\frac{2\\pi i}{N} . the sum of K K has to conform to the Poincar\u00e9 index theorem. However, generator (handle) cycles can admit unbounded indices. See 5 for exact details. If the input obeys the sum, the result obeys the prescribed indices around the cycles everywhere. The representation is differential , where the single global degree of freedom is resolved by setting a single direction in a single arbitrary face. Note that the correct definition for \u201ccycle curvature\u201d corresponds to the so-called \u201ccycle holonomy\u201d, only up to integer multiples of 2\\pi 2\\pi . However, in the discrete setting, the curvature should theoretically be computed as the exact discrete angle defect, in which for inner vertices we use 2\\pi-\\sum{\\alpha} 2\\pi-\\sum{\\alpha} , and for boundary vertices we use \\pi - \\sum{\\alpha} \\pi - \\sum{\\alpha} ( \\alpha \\alpha are the angles at the corners of a vertex). For a cycle aggregating many vertices, such as a boundary-loop cycle, we add up all the defects. That is required for exact discrete Poincar\u00e9 index consistency. Note that the boundary indices define how many rotations of the vector field the boundary loop \u201csees\u201d. As an example, a constant field on a simple disc in the plane has indices 0 0 for all inner vertices, but the boundary index is in fact 1 1 \u2014This obeys the total index sum \\chi = 2-2g-b = 2-0-1=1 \\chi = 2-2g-b = 2-0-1=1 ( g g stands for genus and b b for number of boundary loops)","title":"401 Index Prescription"},{"location":"tutorial/#basis-cycles","text":"The basis cycles form the cycles around which curvatures (and singularities) have to be prescribed on the mesh. The sum on basis cycles is described in a sparse matrix H H of size |cycles|\\times |E_I| |cycles|\\times |E_I| , where E_I E_I is the number of inner edges in the mesh. Each row in the matrix describes the sum over one cycle, and contains 1 1 or -1 -1 values depending on the (arbitrary) orientation of the dual edge participating in the cycle to the respective face. There are three types of cycles, so ordered in the rows of H H : 1 1 -ring dual cycles around each inner vertex, on which vertex-based singularities can be encoded (the relevant part of H H is basically \\left(d_0\\right)^T \\left(d_0\\right)^T in discrete exterior calculus, restricted to inner edges). Cycles around mesh boundary loops. Cycles around the 2g 2g topological generators (independent handles). The method directional::dual_cycles() computes the proper basis cycles and matrix H H . To be able to intuitively prescribe singularities to inner vertices, the method also returns a conversion vector vertex2cycle , and the list of indices of inner edges from the list of edges. The singularity indices that are prescribed contain the singularity index corresponding to each basis cycle. A value of k \\in \\mathbb{Z} k \\in \\mathbb{Z} represents an \\frac{2\\pi k}{N} \\frac{2\\pi k}{N} rotation around the respective cycle. If the prescribed indices do not conform to the Poincar\u00e9 index theorem, a result will still be computed by least squares, but it will be unpredictable. The algorithm is performed through the function directional::index_prescription() , which can also accept a solver for precomputation, for the purpose of prefactoring H H only once. ( Example 401 ) Indices are prescribed on several vertex singularities, and on a generator loop, to match the index theorem.","title":"Basis Cycles"},{"location":"tutorial/#chapter-5-seamless-parameterization","text":"Directional fields are commonly used to create seamless parameterizations 2 , 9 , 13 . Recall that combing trivializes the matching everywhere except a sparse set of seams. We augment these seams so that the mesh is cut into a topological disc. Then, we treat a combed N N -directional \\left\\{u_0,\\cdots,u_{N-1}\\right\\} \\left\\{u_0,\\cdots,u_{N-1}\\right\\} as a set of N N candidate gradients for N N vertex-based scalar functions \\left\\{F_0,\\cdots,F_{N-1}\\right\\} \\left\\{F_0,\\cdots,F_{N-1}\\right\\} on the cut mesh. We then solve the Poisson problem: $$ F = argmin{\\sum_{i=0}^{N-1}{\\left|\\nabla F_i - u_i\\right|^2}} $$. Consider a seam edge e_{ij} e_{ij} between original vertices v_i v_i and v_j v_j , and between adjacent faces f_k f_k and f_l f_l . The two vertices are then cut into four corners v_{i,k},v_{j,k},v_{i,l},v_{j,l} v_{i,k},v_{j,k},v_{i,l},v_{j,l} . Note that some corners might be identical, if the seam edge is at a singularity. Across the seam edge, we enforce the (linear) seamless conditions: F_{i,k}= \\pi_e \\cdot F_{i,l} + T_e, F_{i,k}= \\pi_e \\cdot F_{i,l} + T_e, where \\pi_e:N \\times N \\pi_e:N \\times N is a permutation matrix attached to the (dual) edge e e , matching values in the integrated function F F as it did for the directional field v v . and T_e:N \\times 1 T_e:N \\times 1 is a translational jump (also: period jump), that encodes the discontinuity in F F across the seam. For quick intuition, this encodes the integration of the function over a loop around the mesh beginning and ending with the seam edge: in a quad-mesh parameterization, it is the number of quads in such a loop. Seamless parameterizations are denoted as such for that obeying the seamless constraints; it can be easily shown 9 that the translational jumps T_e T_e is in fact uniform across seam curves between singularities. Thus, the number of such translational jump variables is the number of seam curves in the mesh ( \\times N \\times N )","title":"Chapter 5: Seamless Parameterization"},{"location":"tutorial/#501-seamless-parameterization","text":"In Example 501 we demonstrate the computation of such a parameterization. The core functionality is in these lines: directional :: ParameterizationData pd ; directional :: cut_mesh_with_singularities ( VMeshWhole , FMeshWhole , singVertices , pd . face2cut ); ... directional :: setup_parameterization ( N , VMeshWhole , FMeshWhole , EV , EF , FE , combedMatching , singVertices , pd , VMeshCut , FMeshCut ); double lengthRatio = 0.01 ; bool isInteger = false ; //do not do translational seamless. std :: cout << \"Solving parameterization\" << std :: endl ; directional :: parameterize ( VMeshWhole , FMeshWhole , FE , combedField , lengthRatio , pd , VMeshCut , FMeshCut , isInteger , cutUV ); directional::cut_mesh_with_singularities() encodes the the seams in pd.face2cut . directional::setup_parameterization() creates the Poisson system and the constraints, and creates the actual cut mesh in VMeshCut and FMeshCut . directional::parameterize() solves the parameterization, and puts the result in cutUV . The functionality is currently limited only to 2^2 2^2 fields ( N=4 N=4 ) with symmetry assumed. lengthRatio encodes a global scale for the Poisson problem (scaling the fields uniformly), where the ratio is measured against the bounding box diagonal. The variable isInteger refers set to false which means that the parameterization would only be rotationally-seamless ; the appearance across the seams would align only in direction. The next example considers the stronger option. ( Example 501 ) Left: directional field. Right: rotationally-seamless parameterization. Note that the direction of the texture aligns across seams.","title":"501 Seamless Parameterization"},{"location":"tutorial/#502-mixed-integer-parametrization","text":"To use seamless parameterizations for the purpose of quad meshing, we require the texture to be fully-seamless across seams. With this, the seams are virtually invisible on the cut mesh. This can be done by setting all T_e T_e to values in 2\\mathbb{Z} 2\\mathbb{Z} (for why double integers are necessary, see 9 ). The solving is done by simple iterative rounding 2 : we choose the value in T_e T_e which is the closest to a double integer, round and fix it, and repeat until all T_e T_e are rounded. Note that CoMISo 3 has a more sophisticated Gauss-Seidel rounding algorithm that is more efficient; however, we include an implementation of our simpler version in Directional to avoid the dependency, and since our version will be used for general N N -function parameterization in future versions of Directional. Mixed-integer parameterization is demonstrated in Example 502 . The essential difference from Example 501 is by simply setting isInteger=true , when passed to directional::parameterize() . Note: The input field horsers-cf.rawfield is computed according to Example 303 to have negligible PolyCurl. As such, the rotationally-seamless parameterization has a very low error ( L_\\infty L_\\infty of 1.25778\\cdot 10^{-5} 1.25778\\cdot 10^{-5} ). The rounding iterations incur some error, but it is rather low as well (after rounding 116 116 variables it climbs to L_\\infty=0.657496 L_\\infty=0.657496 ); we therefore recommend to warm-start a mixed-integer parameterization with a curl-reduced directional field. ( Example 502 ) Left to right: directional field, rotationally-seamless parameterization (before rounding), fully-seamless parameterization.","title":"502 Mixed-Integer Parametrization"},{"location":"tutorial/#outlook-for-continuing-development","text":"Directional is a budding project, and there are many algorithms in the state-of-the-art that we look forward to implement, with the help of volunteer researchers and practitioners from the field. Prominent examples of desired implementations are: Support for 3D fields, particularly Octahedral fields 14 , both in tet meshes and with the boundary-element method. A discrete exterior calculus framework. Differential operators and Hodge decomposition. Support for tensor fields. Face-based polar representation, and mixed-integer directional algorithms. Vertex-based representations. Advanced and better visualization techniques.","title":"Outlook for continuing development"},{"location":"tutorial/#references","text":"Omri Azencot, Etienne Corman, Mirela Ben-Chen, Maks Ovsjanikov, Consistent Functional Cross Field Design for Mesh Quadrangulation , 2017. \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt, Mixed-integer quadrangulation , 2009. \u21a9 \u21a9 \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt, Practical Mixed-Integer Optimization for Geometry Processing , 2012. \u21a9 Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly, Shape-Up: Shaping Discrete Geometry with Projections , 2012. \u21a9 Keenan Crane, Mathieu Desbrun, Peter Schr\u00f6der, Trivial Connections on Discrete Surfaces , 2010. \u21a9 \u21a9 \u21a9 \u21a9 Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Designing N-PolyVector Fields with Complex Polynomials , 2014. \u21a9 \u21a9 \u21a9 \u21a9 Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, Integrable PolyVector Fields , 2015. \u21a9 Fernando de Goes, Mathieu Desbrun, Yiying Tong, Vector Field Processing on Triangle Meshes , 2016. \u21a9 Felix K\u00e4lberer, Matthias Nieser, Konrad Polthier, QuadCover - Surface Parameterization using Branched Coverings , 2007 \u21a9 \u21a9 \u21a9 Felix Kn\u00f6ppel, Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der, Globally Optimal Direction Fields , 2013. \u21a9 \u21a9 Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno L\u00e9vy, N-Symmetry Direction Field Design , 2008. \u21a9 \u21a9 \u21a9 Yang Liu, Weiwei Xu, Jun Wang, Lifeng Zhu, Baining Guo, Falai Chen, Guoping Wang, General Planar Quadrilateral Mesh Design Using Conjugate Direction Field , 2008. \u21a9 Ashish Myles, Nico Pietroni, Denis Zorin, Robust Field-aligned Global Parametrization , 2014. \u21a9 Justin Solomon, Amir Vaxman, David Bommes, Boundary Element Octahedral Fields in Volumes , 2017. \u21a9 Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung, Frame Fields: Anisotropic and Non-Orthogonal Cross Fields , 2014. \u21a9 Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen, Directional Field Synthesis, Design, and Processing , 2016. \u21a9 \u21a9","title":"References"},{"location":"website/","text":"Building the Website \u00b6 For developers who want to contribute to the website/documentation of Directional. If you want to preview changes to the Directional website before a commit, you can follow the instructions below. Prerequisites \u00b6 If you do not already have it, install conda on your machine. We recommend using miniconda3 . On Linux you can run: wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh Install the conda environment for the website: conda env create -f libigl-website.yml Using mkdocs \u00b6 Activate the conda environment installed on the previous step: conda activate libigl-website Preview the website locally (run this command in the root folder of the libigl project): mkdocs serve Tip Note The reason we are using python -m mkdocs serve instead of mkdocs serve directly is because we are using local extensions for mkdocs. Those extensions are located in the scripts/ folder of libigl. Running mkdocs as a module adds the current directory to the PYTHONPATH , allowing us to load those extensions without installing them on the system or in a virtualenv. References \u00b6 MkDocs Material Theme","title":"Website"},{"location":"website/#building-the-website","text":"For developers who want to contribute to the website/documentation of Directional. If you want to preview changes to the Directional website before a commit, you can follow the instructions below.","title":"Building the Website"},{"location":"website/#prerequisites","text":"If you do not already have it, install conda on your machine. We recommend using miniconda3 . On Linux you can run: wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh Install the conda environment for the website: conda env create -f libigl-website.yml","title":"Prerequisites"},{"location":"website/#using-mkdocs","text":"Activate the conda environment installed on the previous step: conda activate libigl-website Preview the website locally (run this command in the root folder of the libigl project): mkdocs serve Tip Note The reason we are using python -m mkdocs serve instead of mkdocs serve directly is because we are using local extensions for mkdocs. Those extensions are located in the scripts/ folder of libigl. Running mkdocs as a module adds the current directory to the PYTHONPATH , allowing us to load those extensions without installing them on the system or in a virtualenv.","title":"Using mkdocs"},{"location":"website/#references","text":"MkDocs Material Theme","title":"References"}]}